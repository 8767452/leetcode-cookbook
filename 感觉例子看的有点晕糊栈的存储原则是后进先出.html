<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>2 感觉例子看的有点晕糊，栈的存储原则是后进先出 | 剑指offer</title>
  <meta name="description" content="2 感觉例子看的有点晕糊，栈的存储原则是后进先出 | 剑指offer" />
  <meta name="generator" content="bookdown 0.19 and GitBook 2.6.7" />

  <meta property="og:title" content="2 感觉例子看的有点晕糊，栈的存储原则是后进先出 | 剑指offer" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="2 感觉例子看的有点晕糊，栈的存储原则是后进先出 | 剑指offer" />
  
  
  

<meta name="author" content="高文欣" />


<meta name="date" content="2020-08-19" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="剑指offer题解.html"/>

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="剑指offer题解.html"><a href="剑指offer题解.html"><i class="fa fa-check"></i><b>1</b> 剑指offer题解</a><ul>
<li class="chapter" data-level="1.1" data-path="剑指offer题解.html"><a href="剑指offer题解.html#二维数组中的查找"><i class="fa fa-check"></i><b>1.1</b> 二维数组中的查找</a></li>
<li class="chapter" data-level="1.2" data-path="剑指offer题解.html"><a href="剑指offer题解.html#替换空格"><i class="fa fa-check"></i><b>1.2</b> 替换空格</a></li>
<li class="chapter" data-level="1.3" data-path="剑指offer题解.html"><a href="剑指offer题解.html#从头到尾打印链表"><i class="fa fa-check"></i><b>1.3</b> 从头到尾打印链表</a></li>
<li class="chapter" data-level="1.4" data-path="剑指offer题解.html"><a href="剑指offer题解.html#重建二叉树"><i class="fa fa-check"></i><b>1.4</b> 重建二叉树</a></li>
<li class="chapter" data-level="1.5" data-path="剑指offer题解.html"><a href="剑指offer题解.html#两个栈实现队列"><i class="fa fa-check"></i><b>1.5</b> 两个栈实现队列</a></li>
<li class="chapter" data-level="1.6" data-path="剑指offer题解.html"><a href="剑指offer题解.html#旋转数组中最小的数"><i class="fa fa-check"></i><b>1.6</b> 旋转数组中最小的数</a></li>
<li class="chapter" data-level="1.7" data-path="剑指offer题解.html"><a href="剑指offer题解.html#斐波那契数列"><i class="fa fa-check"></i><b>1.7</b> 斐波那契数列</a></li>
<li class="chapter" data-level="1.8" data-path="剑指offer题解.html"><a href="剑指offer题解.html#青蛙跳台阶问题"><i class="fa fa-check"></i><b>1.8</b> 青蛙跳台阶问题</a></li>
<li class="chapter" data-level="1.9" data-path="剑指offer题解.html"><a href="剑指offer题解.html#变态跳台问题"><i class="fa fa-check"></i><b>1.9</b> 变态跳台问题</a></li>
<li class="chapter" data-level="1.10" data-path="剑指offer题解.html"><a href="剑指offer题解.html#矩形覆盖"><i class="fa fa-check"></i><b>1.10</b> 矩形覆盖</a></li>
<li class="chapter" data-level="1.11" data-path="剑指offer题解.html"><a href="剑指offer题解.html#二进制中的1的个数"><i class="fa fa-check"></i><b>1.11</b> 二进制中的1的个数</a></li>
<li class="chapter" data-level="1.12" data-path="剑指offer题解.html"><a href="剑指offer题解.html#数值得整熟次方"><i class="fa fa-check"></i><b>1.12</b> 数值得整熟次方</a></li>
<li class="chapter" data-level="1.13" data-path="剑指offer题解.html"><a href="剑指offer题解.html#调整数组顺序使其位于整熟前面"><i class="fa fa-check"></i><b>1.13</b> 调整数组顺序使其位于整熟前面</a></li>
<li class="chapter" data-level="1.14" data-path="剑指offer题解.html"><a href="剑指offer题解.html#链表的倒数第k个节点"><i class="fa fa-check"></i><b>1.14</b> 链表的倒数第k个节点</a></li>
<li class="chapter" data-level="1.15" data-path="剑指offer题解.html"><a href="剑指offer题解.html#反转链表"><i class="fa fa-check"></i><b>1.15</b> 反转链表</a></li>
<li class="chapter" data-level="1.16" data-path="剑指offer题解.html"><a href="剑指offer题解.html#合并两个有序链表"><i class="fa fa-check"></i><b>1.16</b> 合并两个有序链表</a></li>
<li class="chapter" data-level="1.17" data-path="剑指offer题解.html"><a href="剑指offer题解.html#树的子结构"><i class="fa fa-check"></i><b>1.17</b> 树的子结构</a></li>
<li class="chapter" data-level="1.18" data-path="剑指offer题解.html"><a href="剑指offer题解.html#二叉树的镜像"><i class="fa fa-check"></i><b>1.18</b> 二叉树的镜像</a></li>
<li class="chapter" data-level="1.19" data-path="剑指offer题解.html"><a href="剑指offer题解.html#顺时针打印矩阵"><i class="fa fa-check"></i><b>1.19</b> 顺时针打印矩阵</a></li>
<li class="chapter" data-level="1.20" data-path="剑指offer题解.html"><a href="剑指offer题解.html#包含min函数的栈"><i class="fa fa-check"></i><b>1.20</b> 包含min函数的栈</a></li>
<li class="chapter" data-level="1.21" data-path="剑指offer题解.html"><a href="剑指offer题解.html#栈的压入和弹出顺序"><i class="fa fa-check"></i><b>1.21</b> 栈的压入和弹出顺序</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><i class="fa fa-check"></i><b>2</b> 感觉例子看的有点晕糊，栈的存储原则是后进先出</a><ul>
<li class="chapter" data-level="2.1" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#最小的k个数"><i class="fa fa-check"></i><b>2.1</b> 最小的K个数</a></li>
<li class="chapter" data-level="2.2" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#最大子序和"><i class="fa fa-check"></i><b>2.2</b> 最大子序和</a></li>
<li class="chapter" data-level="2.3" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#数组中出现次数超过一半的数字"><i class="fa fa-check"></i><b>2.3</b> 数组中出现次数超过一半的数字</a></li>
<li class="chapter" data-level="2.4" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#字符串的排序"><i class="fa fa-check"></i><b>2.4</b> 字符串的排序</a></li>
<li class="chapter" data-level="2.5" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#有效的括号"><i class="fa fa-check"></i><b>2.5</b> 有效的括号</a></li>
<li class="chapter" data-level="2.6" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#找零"><i class="fa fa-check"></i><b>2.6</b> 找零</a></li>
<li class="chapter" data-level="2.7" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#点游戏"><i class="fa fa-check"></i><b>2.7</b> 24点游戏</a></li>
<li class="chapter" data-level="2.8" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#从上到下打印二叉树"><i class="fa fa-check"></i><b>2.8</b> 从上到下打印二叉树</a></li>
<li class="chapter" data-level="2.9" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#二叉树的后续遍历"><i class="fa fa-check"></i><b>2.9</b> 二叉树的后续遍历</a></li>
<li class="chapter" data-level="2.10" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#二叉树中和为某一路径值"><i class="fa fa-check"></i><b>2.10</b> 二叉树中和为某一路径值</a></li>
<li class="chapter" data-level="2.11" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#复杂链表的复制"><i class="fa fa-check"></i><b>2.11</b> 复杂链表的复制</a></li>
<li class="chapter" data-level="2.12" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#反转单词顺序"><i class="fa fa-check"></i><b>2.12</b> 反转单词顺序</a></li>
<li class="chapter" data-level="2.13" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#左旋字符串"><i class="fa fa-check"></i><b>2.13</b> 左旋字符串</a></li>
<li class="chapter" data-level="2.14" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#把数组排成最小整数"><i class="fa fa-check"></i><b>2.14</b> 把数组排成最小整数</a></li>
<li class="chapter" data-level="2.15" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#丑数"><i class="fa fa-check"></i><b>2.15</b> 丑数</a></li>
<li class="chapter" data-level="2.16" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#第一个只出现一次的字符串"><i class="fa fa-check"></i><b>2.16</b> 第一个只出现一次的字符串</a></li>
<li class="chapter" data-level="2.17" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#数组中的逆序对"><i class="fa fa-check"></i><b>2.17</b> 数组中的逆序对</a></li>
<li class="chapter" data-level="2.18" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#两个链表的第一个公共节点"><i class="fa fa-check"></i><b>2.18</b> 两个链表的第一个公共节点</a></li>
<li class="chapter" data-level="2.19" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#数字在升序数组中出现的次数"><i class="fa fa-check"></i><b>2.19</b> 数字在升序数组中出现的次数</a></li>
<li class="chapter" data-level="2.20" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#平衡二叉树"><i class="fa fa-check"></i><b>2.20</b> 平衡二叉树</a></li>
<li class="chapter" data-level="2.21" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#数组中只出现一次的数"><i class="fa fa-check"></i><b>2.21</b> 数组中只出现一次的数</a></li>
<li class="chapter" data-level="2.22" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#和为s的连续子序列"><i class="fa fa-check"></i><b>2.22</b> 和为S的连续子序列</a></li>
<li class="chapter" data-level="2.23" data-path="感觉例子看的有点晕糊栈的存储原则是后进先出.html"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#两个数之和为s"><i class="fa fa-check"></i><b>2.23</b> 两个数之和为s</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">剑指offer</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="感觉例子看的有点晕糊栈的存储原则是后进先出" class="section level1">
<h1><span class="header-section-number">2</span> 感觉例子看的有点晕糊，栈的存储原则是后进先出</h1>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-1"></a>class Solution<span class="op">:</span></span>
<span id="cb21-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-2"></a><span class="st">    </span>def <span class="kw">IsPopOrder</span>(self, pushV, popV)<span class="op">:</span></span>
<span id="cb21-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-3"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb21-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-4"></a><span class="st">        </span>stack=[]</span>
<span id="cb21-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-5"></a>        <span class="cf">while</span> popV<span class="op">:</span></span>
<span id="cb21-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-6"></a><span class="st">            </span><span class="co">##如果stack的最后一个元素与popV中第一个元素相等，将两个元素都弹出</span></span>
<span id="cb21-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-7"></a><span class="st">            </span><span class="cf">if</span> stack and stack[<span class="op">-</span><span class="dv">1</span>]<span class="op">==</span>popV[<span class="dv">0</span>]<span class="op">:</span></span>
<span id="cb21-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-8"></a><span class="st">                </span><span class="kw">stack.pop</span>()</span>
<span id="cb21-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-9"></a>                <span class="kw">popV.pop</span>(<span class="dv">0</span>)</span>
<span id="cb21-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-10"></a>            <span class="co"># 如果pushV中有数据，压入stack</span></span>
<span id="cb21-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-11"></a>            elif pushV<span class="op">:</span></span>
<span id="cb21-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-12"></a><span class="st">                </span><span class="kw">stack.append</span>(<span class="kw">pushV.pop</span>(<span class="dv">0</span>))</span>
<span id="cb21-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-13"></a>            <span class="co"># 上面情况都不满足，直接返回false。</span></span>
<span id="cb21-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-14"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb21-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-15"></a><span class="st">                </span>return False</span>
<span id="cb21-16"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-16"></a>        return True</span>
<span id="cb21-17"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb21-17"></a>        </span></code></pre></div>
<div id="最小的k个数" class="section level2">
<h2><span class="header-section-number">2.1</span> 最小的K个数</h2>
<p><strong>题目描述</strong>
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb22-1"></a>class Solution<span class="op">:</span></span>
<span id="cb22-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb22-2"></a><span class="st">    </span>def <span class="kw">GetLeastNumbers_Solution</span>(self, tinput, k)<span class="op">:</span></span>
<span id="cb22-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb22-3"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb22-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb22-4"></a><span class="st">        </span><span class="cf">if</span> tinput<span class="op">==</span>[] or k<span class="op">&gt;</span><span class="kw">len</span>(tinput)<span class="op">:</span></span>
<span id="cb22-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb22-5"></a><span class="st">            </span>return []</span>
<span id="cb22-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb22-6"></a>        <span class="kw">tinput.sort</span>()</span>
<span id="cb22-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb22-7"></a>        return tinput[<span class="op">:</span>k]</span></code></pre></div>
</div>
<div id="最大子序和" class="section level2">
<h2><span class="header-section-number">2.2</span> 最大子序和</h2>
<p><strong>题目描述</strong>
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<p>典型的动态规划</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-1"></a>class Solution<span class="op">:</span></span>
<span id="cb23-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-2"></a><span class="st">    </span>def <span class="kw">FindGreatestSumOfSubArray</span>(self, array)<span class="op">:</span></span>
<span id="cb23-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-3"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb23-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-4"></a><span class="st">        </span>n=<span class="kw">len</span>(array)</span>
<span id="cb23-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-5"></a>        <span class="cf">if</span> not array<span class="op">:</span></span>
<span id="cb23-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-6"></a><span class="st">            </span>return </span>
<span id="cb23-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-7"></a>        <span class="cf">if</span> <span class="kw">len</span>(array)<span class="op">==</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb23-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-8"></a><span class="st">            </span>return array[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb23-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-9"></a>        dp=[<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb23-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-10"></a>        dp[<span class="dv">0</span>]=array[<span class="dv">0</span>]</span>
<span id="cb23-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-11"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,n)<span class="op">:</span></span>
<span id="cb23-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-12"></a><span class="st">            </span>dp[i]=<span class="kw">max</span>(dp[i<span class="dv">-1</span>]<span class="op">+</span>array[i],array[i])</span>
<span id="cb23-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb23-13"></a>        return <span class="kw">max</span>(dp)</span></code></pre></div>
</div>
<div id="数组中出现次数超过一半的数字" class="section level2">
<h2><span class="header-section-number">2.3</span> 数组中出现次数超过一半的数字</h2>
<p><strong>题目描述</strong>
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>给出两种解法</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-1"></a></span>
<span id="cb24-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-2"></a><span class="co"># 数量超过数组长度一半的数字排序后必定占据中间位置</span></span>
<span id="cb24-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-3"></a>class Solution<span class="op">:</span></span>
<span id="cb24-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-4"></a><span class="st">    </span>def <span class="kw">MoreThanHalfNum_Solution</span>(self, numbers)<span class="op">:</span></span>
<span id="cb24-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-5"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb24-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-6"></a><span class="st">        </span><span class="kw">numbers.sort</span>()</span>
<span id="cb24-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-7"></a>        theone =<span class="st"> </span>numbers[<span class="kw">len</span>(numbers)<span class="op">/</span><span class="dv">2</span>]</span>
<span id="cb24-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-8"></a>        <span class="cf">if</span> <span class="kw">numbers.count</span>(theone) <span class="op">&gt;</span><span class="st"> </span><span class="kw">len</span>(numbers)<span class="op">/</span><span class="dv">2</span><span class="op">:</span></span>
<span id="cb24-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-9"></a><span class="st">            </span>return theone</span>
<span id="cb24-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb24-10"></a>        return  <span class="dv">0</span></span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-1"></a>class Solution<span class="op">:</span></span>
<span id="cb25-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-2"></a><span class="st">    </span>def <span class="kw">MoreThanHalfNum_Solution</span>(self, numbers)<span class="op">:</span></span>
<span id="cb25-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-3"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb25-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-4"></a><span class="st">        </span>A =<span class="st"> </span>{}</span>
<span id="cb25-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-5"></a>        <span class="cf">for</span> i <span class="cf">in</span> numbers<span class="op">:</span></span>
<span id="cb25-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-6"></a><span class="st">            </span><span class="cf">if</span> i <span class="cf">in</span> A<span class="op">:</span></span>
<span id="cb25-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-7"></a><span class="st">                </span>A[i] <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb25-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-8"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb25-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-9"></a><span class="st">                </span>A[i] =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb25-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-10"></a>        maxnum =<span class="st"> </span><span class="kw">max</span>(<span class="kw">A.values</span>())</span>
<span id="cb25-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-11"></a>        <span class="kw">print</span>(maxnum)</span>
<span id="cb25-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-12"></a>        <span class="cf">if</span> <span class="dv">2</span><span class="op">*</span>maxnum <span class="op">&gt;</span><span class="st"> </span><span class="kw">len</span>(numbers)<span class="op">:</span></span>
<span id="cb25-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-13"></a><span class="st">            </span>return [k <span class="cf">for</span> k,v <span class="cf">in</span> <span class="kw">A.items</span>() <span class="cf">if</span> v<span class="op">==</span><span class="st"> </span><span class="kw">max</span>(<span class="kw">A.values</span>())][<span class="dv">0</span>]</span>
<span id="cb25-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-14"></a>        <span class="cf">else</span><span class="op">:</span></span>
<span id="cb25-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb25-15"></a><span class="st">            </span>return <span class="dv">0</span></span></code></pre></div>
</div>
<div id="字符串的排序" class="section level2">
<h2><span class="header-section-number">2.4</span> 字符串的排序</h2>
<p><strong>题目描述</strong>
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
输入描述:
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<p>先给一个能调包做的</p>
<p><strong>b站笔试题</strong></p>
</div>
<div id="有效的括号" class="section level2">
<h2><span class="header-section-number">2.5</span> 有效的括号</h2>
<p>题目描述：</p>
<p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<p>输入: “()”
输出: true
示例 2:</p>
<p>输入: “()<span></span>”
输出: true
示例 3:</p>
<p>输入: “(]”
输出: false
示例 4:</p>
<p>输入: “([)]”
输出: false
示例 5:</p>
<p>输入: “{[]}”
输出: true</p>
<p>知识点：栈</p>
<p><strong>解题思路</strong>
当开始接触题目时，我们会不禁想到如果计算出左括号的数量，和右括号的数量，如果每种括号左右数量相同, 会不会就是有效的括号了呢?
事实上不是的，假如输入是 [ (] ) ，每种括号的左右数量分别相等, 但不是有效的括号。这是因为结果还与括号 的位置有关。
仔细分析我们发现，对于有效的括号, 它的部分子表达式仍然是有效的括号, 比如 <span class="math inline">\(\quad\{()[()]\}\)</span> 是一个有效的括 号, <span class="math inline">\(\quad()[\{\}]\)</span> 是有效的括号, <span class="math inline">\(\quad[()]\)</span> 也是有效的括号。并且当我们<strong>每次删除一个最小的括号对时，我们会逐渐将 括号删除完</strong>。比如下面的例子。</p>
<p><img src="figs/khao.png" /></p>
<p>这个思考的过程其实就是栈的实现过程。因此我们考虑使用栈，当遇到匹配的最小括号对时，我们将这对括号从栈中删除（即出栈），如果最后栈为空，那么它是有效的括号，反之不是。</p>
<p>代码中我们使用了哈希表来判断是否能够形成括号，从而决定进行入栈操作还是出栈操作。<a href="https://leetcode-cn.com/problems/valid-parentheses/solution/zhu-bu-fen-xi-tu-jie-zhan-zhan-shi-zui-biao-zhun-d/">leetcode</a></p>
<ul>
<li>使用栈，是左括号代表入栈，是右括号代表出栈</li>
<li>如果要出栈，出栈的元素要与当前元素匹配</li>
<li>最终栈要为空</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-1"></a>class Solution<span class="op">:</span></span>
<span id="cb26-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-2"></a><span class="st">    </span>def <span class="kw">isValid</span>(self, s<span class="op">:</span><span class="st"> </span>str) -&gt;<span class="st"> </span>bool<span class="op">:</span></span>
<span id="cb26-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-3"></a><span class="st">        </span>stack=[]                            <span class="co">#设置一个列表，把该列表当做栈来使用即可。</span></span>
<span id="cb26-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-4"></a>        dic={<span class="st">&#39;)&#39;</span><span class="op">:</span><span class="st">&#39;(&#39;</span>,<span class="st">&#39;}&#39;</span><span class="op">:</span><span class="st">&#39;{&#39;</span>,<span class="st">&#39;]&#39;</span><span class="op">:</span><span class="st">&#39;[&#39;</span>}       <span class="co">#使用字典存储括号,并且右括号为key,左括号为value</span></span>
<span id="cb26-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-5"></a>        <span class="cf">for</span> char <span class="cf">in</span> s<span class="op">:</span></span>
<span id="cb26-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-6"></a><span class="st">            </span><span class="cf">if</span> char <span class="cf">in</span> <span class="kw">dic.values</span>()<span class="op">:</span><span class="st">        </span><span class="co">#左括号就入栈</span></span>
<span id="cb26-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-7"></a><span class="st">                </span><span class="kw">stack.append</span>(char)</span>
<span id="cb26-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-8"></a>            elif char <span class="cf">in</span> <span class="kw">dic.keys</span>()<span class="op">:</span><span class="st">        </span><span class="co">#有右括号的话就进行比较，</span></span>
<span id="cb26-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-9"></a><span class="st">                </span><span class="cf">if</span> stack<span class="op">==</span>[] or dic[char] <span class="op">!=</span><span class="st"> </span><span class="kw">stack.pop</span>()<span class="op">:</span></span>
<span id="cb26-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-10"></a><span class="st">                    </span>return False</span>
<span id="cb26-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-11"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb26-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-12"></a><span class="st">                </span>return False                <span class="co">#不再字典中的输入直接输出错误</span></span>
<span id="cb26-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-13"></a></span>
<span id="cb26-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb26-14"></a>        return stack<span class="op">==</span>[]</span></code></pre></div>
<p>一个比较骚的题解</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb27-1"></a>class Solution<span class="op">:</span></span>
<span id="cb27-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb27-2"></a><span class="st">    </span>def <span class="kw">isValid</span>(self, s)<span class="op">:</span></span>
<span id="cb27-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb27-3"></a><span class="st">        </span><span class="cf">while</span> <span class="st">&#39;{}&#39;</span> <span class="cf">in</span> s or <span class="st">&#39;()&#39;</span> <span class="cf">in</span> s or <span class="st">&#39;[]&#39;</span> <span class="cf">in</span> s<span class="op">:</span></span>
<span id="cb27-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb27-4"></a><span class="st">            </span>s =<span class="st"> </span><span class="kw">s.replace</span>(<span class="st">&#39;{}&#39;</span>, <span class="st">&#39;&#39;</span>)</span>
<span id="cb27-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb27-5"></a>            s =<span class="st"> </span><span class="kw">s.replace</span>(<span class="st">&#39;[]&#39;</span>, <span class="st">&#39;&#39;</span>)</span>
<span id="cb27-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb27-6"></a>            s =<span class="st"> </span><span class="kw">s.replace</span>(<span class="st">&#39;()&#39;</span>, <span class="st">&#39;&#39;</span>)</span>
<span id="cb27-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb27-7"></a>        return s <span class="op">==</span><span class="st"> &#39;&#39;</span></span></code></pre></div>
</div>
<div id="找零" class="section level2">
<h2><span class="header-section-number">2.6</span> 找零</h2>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/944e5ca0ea88471fbfa73061ebe95728" class="uri">https://www.nowcoder.com/questionTerminal/944e5ca0ea88471fbfa73061ebe95728</a>
来源：牛客网</p>
<p>Z国的货币系统包含面值1元、4元、16元、64元共计4种硬币，以及面值1024元的纸币。现在小Y使用1024元的纸币购买了一件价值为N (0 &lt; N 1024)N(0&lt;N≤1024)的商品，请问最少他会收到多少硬币？</p>
<p>也就是买柠檬水找钱的问题</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-1"></a>def <span class="kw">zl</span>(n)<span class="op">:</span></span>
<span id="cb28-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-2"></a><span class="st">    </span>coins=[<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">16</span>,<span class="dv">64</span>]</span>
<span id="cb28-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-3"></a>    </span>
<span id="cb28-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-4"></a>    s=<span class="dv">1024</span><span class="op">-</span>n<span class="op">+</span><span class="dv">1</span></span>
<span id="cb28-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-5"></a>    dp=[<span class="dv">1024</span>]<span class="op">*</span>(s)</span>
<span id="cb28-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-6"></a>    dp[<span class="dv">0</span>]=<span class="dv">0</span></span>
<span id="cb28-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-7"></a>    <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,s)<span class="op">:</span></span>
<span id="cb28-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-8"></a><span class="st">        </span><span class="cf">for</span> c <span class="cf">in</span> coins<span class="op">:</span></span>
<span id="cb28-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-9"></a><span class="st">            </span><span class="cf">if</span> i<span class="op">-</span>c<span class="op">&gt;=</span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb28-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-10"></a><span class="st">                </span>dp[i]=<span class="kw">min</span>(dp[i<span class="op">-</span>c]<span class="op">+</span><span class="dv">1</span>,dp[i])</span>
<span id="cb28-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-11"></a>                </span>
<span id="cb28-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb28-12"></a>    return dp[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
</div>
<div id="点游戏" class="section level2">
<h2><span class="header-section-number">2.7</span> 24点游戏</h2>
<p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。</p>
<p>示例 1:</p>
<p>输入: [4, 1, 8, 7]
输出: True
解释: (8-4) * (7-1) = 24
示例 2:</p>
<p>输入: [1, 2, 1, 2]
输出: False</p>
<p>注意:</p>
<p>除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。
每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。
你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</p>
<blockquote>
<p>四个数取出两个数之后,做加减乘除处理之后加入到原数组中会剩下三个数,递归交给下一层去处理<a href="https://leetcode-cn.com/problems/24-game/solution/python-dfsdi-gui-by-akari-5/">akari-5</a></p>
</blockquote>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-1"></a>class Solution<span class="op">:</span></span>
<span id="cb29-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-2"></a><span class="st">    </span>def <span class="kw">judgePoint24</span>(self, nums<span class="op">:</span><span class="st"> </span>List[int]) -&gt;<span class="st"> </span>bool<span class="op">:</span></span>
<span id="cb29-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-3"></a><span class="st">        </span><span class="cf">if</span> not nums<span class="op">:</span><span class="st"> </span>return False</span>
<span id="cb29-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-4"></a>        def <span class="kw">helper</span>(nums)<span class="op">:</span></span>
<span id="cb29-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-5"></a><span class="st">            </span><span class="cf">if</span> <span class="kw">len</span>(nums) <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="st"> </span>return <span class="kw">abs</span>(nums[<span class="dv">0</span>]<span class="op">-</span><span class="dv">24</span>) <span class="op">&lt;</span><span class="st"> </span><span class="fl">1e-6</span></span>
<span id="cb29-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-6"></a>            <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(nums))<span class="op">:</span></span>
<span id="cb29-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-7"></a><span class="st">                </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(nums))<span class="op">:</span></span>
<span id="cb29-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-8"></a><span class="st">                    </span><span class="cf">if</span> i <span class="op">!=</span><span class="st"> </span>j<span class="op">:</span></span>
<span id="cb29-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-9"></a><span class="st">                        </span>newnums =<span class="st"> </span>[nums[k] <span class="cf">for</span> k <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(nums)) <span class="cf">if</span> i <span class="op">!=</span><span class="st"> </span>k <span class="op">!=</span><span class="st"> </span>j]</span>
<span id="cb29-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-10"></a>                        <span class="cf">if</span> <span class="kw">helper</span>(newnums <span class="op">+</span><span class="st"> </span>[nums[i]<span class="op">+</span>nums[j]])<span class="op">:</span><span class="st"> </span>return True</span>
<span id="cb29-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-11"></a>                        <span class="cf">if</span> <span class="kw">helper</span>(newnums <span class="op">+</span><span class="st"> </span>[nums[i]<span class="op">-</span>nums[j]])<span class="op">:</span><span class="st"> </span>return True</span>
<span id="cb29-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-12"></a>                        <span class="cf">if</span> <span class="kw">helper</span>(newnums <span class="op">+</span><span class="st"> </span>[nums[i]<span class="op">*</span>nums[j]])<span class="op">:</span><span class="st"> </span>return True</span>
<span id="cb29-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-13"></a>                        <span class="cf">if</span> nums[j] <span class="op">!=</span><span class="st"> </span><span class="dv">0</span> and <span class="kw">helper</span>(newnums <span class="op">+</span><span class="st"> </span>[nums[i]<span class="op">/</span>nums[j]])<span class="op">:</span><span class="st"> </span>return True</span>
<span id="cb29-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-14"></a>            return False</span>
<span id="cb29-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb29-15"></a>        return <span class="kw">helper</span>(nums)</span></code></pre></div>
</div>
<div id="从上到下打印二叉树" class="section level2">
<h2><span class="header-section-number">2.8</span> 从上到下打印二叉树</h2>
<p><strong>题目描述</strong>
从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>思路：二叉树的层次遍历,一层一层遍历完继续下一层</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb30-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-2"></a><span class="co"># class TreeNode:</span></span>
<span id="cb30-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-3"></a>def <span class="kw">__init__</span>(self, x)<span class="op">:</span></span>
<span id="cb30-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-4"></a><span class="st">        </span>self.val =<span class="st"> </span>x</span>
<span id="cb30-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-5"></a>        self.left =<span class="st"> </span>None</span>
<span id="cb30-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-6"></a>        self.right =<span class="st"> </span>None</span>
<span id="cb30-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-7"></a>class Solution<span class="op">:</span></span>
<span id="cb30-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-8"></a><span class="st">    </span><span class="co"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span>
<span id="cb30-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-9"></a><span class="st">    </span>def <span class="kw">PrintFromTopToBottom</span>(self, root)<span class="op">:</span></span>
<span id="cb30-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-10"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb30-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-11"></a><span class="st">        </span><span class="co">#</span></span>
<span id="cb30-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-12"></a><span class="st">        </span><span class="cf">if</span> not root<span class="op">:</span></span>
<span id="cb30-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-13"></a><span class="st">            </span>return <span class="st">&#39;&#39;</span></span>
<span id="cb30-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-14"></a>        </span>
<span id="cb30-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-15"></a>        que=[root] <span class="co">#根节点保存在队列中</span></span>
<span id="cb30-16"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-16"></a>        res=[] <span class="co">#用一个list保存输出值</span></span>
<span id="cb30-17"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-17"></a>        <span class="cf">while</span> que<span class="op">:</span></span>
<span id="cb30-18"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-18"></a><span class="st">            </span><span class="cf">if</span> que[<span class="dv">0</span>].left<span class="op">:</span></span>
<span id="cb30-19"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-19"></a><span class="st">                </span><span class="kw">que.append</span>(que[<span class="dv">0</span>].left)</span>
<span id="cb30-20"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-20"></a>            <span class="cf">if</span> que[<span class="dv">0</span>].right<span class="op">:</span></span>
<span id="cb30-21"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-21"></a><span class="st">                </span><span class="kw">que.append</span>(que[<span class="dv">0</span>].right)</span>
<span id="cb30-22"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-22"></a>            <span class="kw">res.append</span>(que[<span class="dv">0</span>].val)</span>
<span id="cb30-23"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-23"></a>            <span class="kw">que.pop</span>(<span class="dv">0</span>) <span class="co">#遍历完一个根和左右就删掉</span></span>
<span id="cb30-24"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-24"></a>        return res</span>
<span id="cb30-25"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb30-25"></a>        </span></code></pre></div>
</div>
<div id="二叉树的后续遍历" class="section level2">
<h2><span class="header-section-number">2.9</span> 二叉树的后续遍历</h2>
<p><strong>题目描述</strong>
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<ul>
<li>后序遍历的序列中，最后一个数字是树的根节点 ，</li>
<li>数组中前面的数字可以分为两部分：第一部分是左子树节点的值，都比根节点的值小；</li>
<li>第二部分 是右子树节点的值，都比根节点的值大，</li>
<li>后面用递归分别判断前后两部分 是否符合以上原则。</li>
</ul>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb31-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-2"></a>class Solution<span class="op">:</span></span>
<span id="cb31-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-3"></a><span class="st">    </span>def <span class="kw">VerifySquenceOfBST</span>(self, sequence)<span class="op">:</span></span>
<span id="cb31-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb31-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-5"></a><span class="st">        </span></span>
<span id="cb31-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-6"></a><span class="st">        </span><span class="cf">if</span> sequence<span class="op">==</span>None or <span class="kw">len</span>(sequence)<span class="op">==</span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb31-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-7"></a><span class="st">            </span>return False</span>
<span id="cb31-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-8"></a>        length=<span class="kw">len</span>(sequence)</span>
<span id="cb31-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-9"></a>        root=sequence[length<span class="dv">-1</span>]</span>
<span id="cb31-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-10"></a>        <span class="co"># 在二叉搜索树中 左子树节点小于根节点</span></span>
<span id="cb31-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-11"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(length)<span class="op">:</span></span>
<span id="cb31-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-12"></a><span class="st">            </span><span class="cf">if</span> sequence[i]<span class="op">&gt;</span>root<span class="op">:</span></span>
<span id="cb31-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-13"></a><span class="st">                </span><span class="cf">break</span></span>
<span id="cb31-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-14"></a>        <span class="co"># 二叉搜索树中右子树的节点都大于根节点</span></span>
<span id="cb31-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-15"></a>        <span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(i,length)<span class="op">:</span></span>
<span id="cb31-16"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-16"></a><span class="st">            </span><span class="cf">if</span> sequence[j]<span class="op">&lt;</span>root<span class="op">:</span></span>
<span id="cb31-17"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-17"></a><span class="st">                </span>return False</span>
<span id="cb31-18"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-18"></a>        <span class="co"># 判断左子树是否为二叉树</span></span>
<span id="cb31-19"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-19"></a>        left=True</span>
<span id="cb31-20"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-20"></a>        <span class="cf">if</span> i<span class="op">&gt;</span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb31-21"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-21"></a><span class="st">            </span>left=<span class="kw">self.VerifySquenceOfBST</span>(sequence[<span class="dv">0</span><span class="op">:</span>i])</span>
<span id="cb31-22"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-22"></a>        <span class="co"># 判断 右子树是否为二叉树</span></span>
<span id="cb31-23"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-23"></a>        right=True</span>
<span id="cb31-24"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-24"></a>        <span class="cf">if</span> i<span class="op">&lt;</span>length<span class="dv">-1</span><span class="op">:</span></span>
<span id="cb31-25"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-25"></a><span class="st">            </span>right=<span class="kw">self.VerifySquenceOfBST</span>(sequence[i<span class="op">:-</span><span class="dv">1</span>])</span>
<span id="cb31-26"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb31-26"></a>        return left and right</span></code></pre></div>
</div>
<div id="二叉树中和为某一路径值" class="section level2">
<h2><span class="header-section-number">2.10</span> 二叉树中和为某一路径值</h2>
<p><strong>题目描述</strong></p>
<p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb32-1"></a>思路是递归：递归方法是返回当前路径下匹配目标值的路径。</span>
<span id="cb32-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb32-2"></a>目标值 =<span class="st"> </span>目标值 <span class="op">-</span><span class="st"> </span>当前节点值</span>
<span id="cb32-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb32-3"></a>共有几种情况：</span>
<span id="cb32-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb32-4"></a>0，当节点为空，return</span>
<span id="cb32-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb32-5"></a>1，当目标值小于0，return</span>
<span id="cb32-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb32-6"></a>2，当目标值为0 并且 节点下无其他节点</span>
<span id="cb32-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb32-7"></a>节点下无其他节点说明是叶子节点，并且路径值的和满足了目标值，添加到结果中  并且return</span>
<span id="cb32-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb32-8"></a>3，当目标值大于0，继续递归</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-1"></a>class Solution<span class="op">:</span></span>
<span id="cb33-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-2"></a><span class="st">    </span><span class="co"># 返回二维列表，内部每个列表表示找到的路径</span></span>
<span id="cb33-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-3"></a><span class="st">    </span>def <span class="kw">FindPath</span>(self, root, expectNumber)<span class="op">:</span></span>
<span id="cb33-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb33-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-5"></a><span class="st">        </span>path =<span class="st"> </span>[]</span>
<span id="cb33-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-6"></a>        res =<span class="st"> </span>[]</span>
<span id="cb33-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-7"></a>        def <span class="kw">dfs</span>(root, sum)<span class="op">:</span></span>
<span id="cb33-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-8"></a><span class="st">            </span><span class="cf">if</span> not root<span class="op">:</span></span>
<span id="cb33-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-9"></a><span class="st">                </span>return</span>
<span id="cb33-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-10"></a>            <span class="kw">path.append</span>(root.val)</span>
<span id="cb33-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-11"></a>            sum <span class="op">-</span><span class="er">=</span><span class="st"> </span>root.val</span>
<span id="cb33-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-12"></a>            <span class="cf">if</span> sum <span class="op">==</span><span class="st"> </span><span class="dv">0</span> and not root.left and not root.right<span class="op">:</span></span>
<span id="cb33-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-13"></a><span class="st">                </span><span class="kw">res.append</span>(path[<span class="op">:</span>])</span>
<span id="cb33-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-14"></a>            <span class="kw">dfs</span>(root.left, sum)</span>
<span id="cb33-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-15"></a>            <span class="kw">dfs</span>(root.right, sum)</span>
<span id="cb33-16"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-16"></a>            <span class="kw">path.pop</span>()</span>
<span id="cb33-17"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-17"></a>            </span>
<span id="cb33-18"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-18"></a>        <span class="kw">dfs</span>(root, expectNumber)</span>
<span id="cb33-19"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb33-19"></a>        return res</span></code></pre></div>
<p><strong>仔细去想上面三个题的思路</strong></p>
</div>
<div id="复杂链表的复制" class="section level2">
<h2><span class="header-section-number">2.11</span> 复杂链表的复制</h2>
<p><strong>题目描述</strong>
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p>思路：</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-1"></a>class Solution<span class="op">:</span></span>
<span id="cb34-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-2"></a><span class="st">    </span><span class="co"># 返回 RandomListNode</span></span>
<span id="cb34-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-3"></a><span class="st">    </span>def <span class="kw">Clone</span>(self, pHead)<span class="op">:</span></span>
<span id="cb34-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb34-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-5"></a><span class="st">        </span><span class="cf">if</span> not pHead<span class="op">:</span></span>
<span id="cb34-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-6"></a><span class="st">            </span>return None</span>
<span id="cb34-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-7"></a>        newp =<span class="st"> </span><span class="kw">RandomListNode</span>(pHead.label)</span>
<span id="cb34-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-8"></a>        newp.random =<span class="st"> </span>pHead.random</span>
<span id="cb34-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-9"></a>        newp.next =<span class="st"> </span><span class="kw">self.Clone</span>(pHead.next)</span>
<span id="cb34-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb34-10"></a>        return newp</span></code></pre></div>
<p>或者下面这一句也是可以的</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb35-1"></a>return <span class="kw">copy.deepcopy</span>(pHead)</span></code></pre></div>
</div>
<div id="反转单词顺序" class="section level2">
<h2><span class="header-section-number">2.12</span> 反转单词顺序</h2>
<p><strong>题目描述</strong></p>
<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<p>能~</p>
<p>字符串的倒序，注意输出的结果表示</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb36-1"></a>class Solution<span class="op">:</span></span>
<span id="cb36-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb36-2"></a><span class="st">    </span>def <span class="kw">ReverseSentence</span>(self, s)<span class="op">:</span></span>
<span id="cb36-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb36-3"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb36-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb36-4"></a><span class="st">        </span><span class="cf">if</span> not s<span class="op">:</span></span>
<span id="cb36-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb36-5"></a><span class="st">            </span>return <span class="st">&#39;&#39;</span></span>
<span id="cb36-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb36-6"></a>        st=<span class="kw">s.split</span>(<span class="st">&#39; &#39;</span>)</span>
<span id="cb36-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb36-7"></a>        res=st[<span class="op">::-</span><span class="dv">1</span>]</span>
<span id="cb36-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb36-8"></a>        return <span class="st">&#39; &#39;</span><span class="kw">.join</span>(res)</span></code></pre></div>
</div>
<div id="左旋字符串" class="section level2">
<h2><span class="header-section-number">2.13</span> 左旋字符串</h2>
<p><strong>题目描述</strong>
汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb37-1"></a>class Solution<span class="op">:</span></span>
<span id="cb37-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb37-2"></a><span class="st">    </span>def <span class="kw">LeftRotateString</span>(self, s, n)<span class="op">:</span></span>
<span id="cb37-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb37-3"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb37-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb37-4"></a><span class="st">        </span>l=<span class="kw">len</span>(s)</span>
<span id="cb37-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb37-5"></a>        return s[n<span class="op">:</span>]<span class="op">+</span>s[<span class="op">:</span>n]</span>
<span id="cb37-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb37-6"></a>        </span></code></pre></div>
</div>
<div id="把数组排成最小整数" class="section level2">
<h2><span class="header-section-number">2.14</span> 把数组排成最小整数</h2>
<p><strong>题目描述</strong>
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p>把数组变成字符串，完事就是常规的冒泡排序就能解决。。冒泡排序的应用</p>
<p>str和int之间的转换，这个需要知道一下</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb38-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-2"></a>class Solution<span class="op">:</span></span>
<span id="cb38-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-3"></a><span class="st">    </span>def <span class="kw">PrintMinNumber</span>(self, numbers)<span class="op">:</span></span>
<span id="cb38-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-4"></a><span class="st">    </span><span class="co"># write code here</span></span>
<span id="cb38-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-5"></a><span class="st">        </span>n =<span class="st"> </span><span class="kw">len</span>(numbers)</span>
<span id="cb38-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-6"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb38-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-7"></a><span class="st">            </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(i<span class="op">+</span><span class="dv">1</span>, n)<span class="op">:</span></span>
<span id="cb38-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-8"></a><span class="st">                </span><span class="cf">if</span> <span class="kw">int</span>(<span class="kw">str</span>(numbers[i]) <span class="op">+</span><span class="st"> </span><span class="kw">str</span>(numbers[j]) <span class="op">&gt;</span><span class="st"> </span><span class="kw">str</span>(numbers[j]) <span class="op">+</span><span class="st"> </span><span class="kw">str</span>(numbers[i]))<span class="op">:</span></span>
<span id="cb38-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-9"></a><span class="st">                    </span>numbers[j], numbers[i] =<span class="st"> </span>numbers[i], numbers[j]</span>
<span id="cb38-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb38-10"></a>        return <span class="st">&#39;&#39;</span><span class="kw">.join</span>([<span class="kw">str</span>(i) <span class="cf">for</span> i <span class="cf">in</span> numbers])</span></code></pre></div>
</div>
<div id="丑数" class="section level2">
<h2><span class="header-section-number">2.15</span> 丑数</h2>
<p><strong>题目描述</strong>
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p><strong>思路：</strong>丑数 = 已有的丑数 * (2,3,5) 得到三个新的丑数，但是新的丑数位置不一定正确，切可能会有重复</p>
<p>所以我们每次只新增一个最小值，然后用三个指针记录当前2，3，5质因子形成的最大丑数位置，这样的话就会形成递增的丑数队列，而且遍历的次数也很容易就知道，即n-1,因为1是第一个丑数，n-1次遍历后，我们就可以得到一个含有n个丑数的有序数组，返回最后一个即可。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb39-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-2"></a>class Solution<span class="op">:</span></span>
<span id="cb39-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-3"></a><span class="st">    </span>def <span class="kw">GetUglyNumber_Solution</span>(self, index)<span class="op">:</span></span>
<span id="cb39-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-4"></a><span class="st">    </span><span class="co"># write code here</span></span>
<span id="cb39-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-5"></a><span class="st">        </span><span class="cf">if</span> index <span class="op">&lt;=</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb39-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-6"></a><span class="st">            </span>return <span class="dv">0</span></span>
<span id="cb39-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-7"></a>        uglyList =<span class="st"> </span>[<span class="dv">1</span>]</span>
<span id="cb39-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-8"></a>        p2 =<span class="st"> </span><span class="dv">0</span> <span class="co"># p2指向小于newUgly且最大的乘以2后可能成为下一个丑数的丑数</span></span>
<span id="cb39-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-9"></a>        p3 =<span class="st"> </span><span class="dv">0</span> <span class="co"># p3指向小于newUgly且最大的乘以3后可能成为下一个丑数的丑数</span></span>
<span id="cb39-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-10"></a>        p5 =<span class="st"> </span><span class="dv">0</span> <span class="co"># p5指向小于newUgly且最大的乘以5后可能成为下一个丑数的丑数</span></span>
<span id="cb39-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-11"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(index<span class="dv">-1</span>)<span class="op">:</span></span>
<span id="cb39-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-12"></a><span class="st">            </span>newUgly =<span class="st"> </span><span class="kw">min</span>(uglyList[p2]<span class="op">*</span><span class="dv">2</span>, uglyList[p3]<span class="op">*</span><span class="dv">3</span>, uglyList[p5]<span class="op">*</span><span class="dv">5</span>)</span>
<span id="cb39-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-13"></a>            <span class="kw">uglyList.append</span>(newUgly)</span>
<span id="cb39-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-14"></a>            <span class="cf">if</span> (newUgly % <span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)<span class="op">:</span></span>
<span id="cb39-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-15"></a><span class="st">                </span>p2 <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb39-16"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-16"></a>            <span class="cf">if</span> (newUgly % <span class="dv">3</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)<span class="op">:</span></span>
<span id="cb39-17"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-17"></a><span class="st">                </span>p3 <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb39-18"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-18"></a>            <span class="cf">if</span> (newUgly % <span class="dv">5</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)<span class="op">:</span></span>
<span id="cb39-19"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-19"></a><span class="st">                </span>p5 <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb39-20"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb39-20"></a>        return uglyList[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
</div>
<div id="第一个只出现一次的字符串" class="section level2">
<h2><span class="header-section-number">2.16</span> 第一个只出现一次的字符串</h2>
<p><strong>题目描述</strong>
在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p>
<p>简单解法，count计数法</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb40-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-2"></a>class Solution<span class="op">:</span></span>
<span id="cb40-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-3"></a><span class="st">    </span>def <span class="kw">FirstNotRepeatingChar</span>(self, s)<span class="op">:</span></span>
<span id="cb40-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb40-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-5"></a><span class="st">        </span><span class="cf">if</span> not s<span class="op">:</span></span>
<span id="cb40-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-6"></a><span class="st">            </span>return <span class="dv">-1</span></span>
<span id="cb40-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-7"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(s))<span class="op">:</span></span>
<span id="cb40-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-8"></a><span class="st">            </span><span class="cf">if</span> <span class="kw">s.count</span>(s[i]) <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb40-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-9"></a><span class="st">                </span>return i</span>
<span id="cb40-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb40-10"></a>        return <span class="dv">-1</span></span></code></pre></div>
<p>或者直接字典</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb41-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb41-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb41-2"></a>class Solution<span class="op">:</span></span>
<span id="cb41-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb41-3"></a><span class="st">    </span>def <span class="kw">FirstNotRepeatingChar</span>(self, s)<span class="op">:</span></span>
<span id="cb41-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb41-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb41-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb41-5"></a><span class="st">        </span><span class="cf">if</span> <span class="kw">len</span>(s) <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb41-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb41-6"></a><span class="st">            </span>return <span class="dv">-1</span></span>
<span id="cb41-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb41-7"></a>        <span class="cf">for</span> index, value <span class="cf">in</span> <span class="kw">enumerate</span>(s)<span class="op">:</span></span>
<span id="cb41-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb41-8"></a><span class="st">            </span><span class="cf">if</span> <span class="kw">s.count</span>(value) <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb41-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb41-9"></a><span class="st">                </span>return index</span></code></pre></div>
</div>
<div id="数组中的逆序对" class="section level2">
<h2><span class="header-section-number">2.17</span> 数组中的逆序对</h2>
<p><strong>题目描述</strong></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<p>输入描述:
题目保证输入的数组中没有的相同的数字</p>
<p>数据范围：</p>
<p>对于%50的数据,size&lt;=10^4</p>
<p>对于%75的数据,size&lt;=10^5</p>
<p>对于%100的数据,size&lt;=2*10^5</p>
<p>示例1
输入1,2,3,4,5,6,7,0</p>
<p>输出7</p>
<p>思路1：先将原序列排序，然后从排完序的数组中取出最小的，它在原数组中的位置表示有多少比它大的数在它前面，每取出一个在原数组中删除该元素，保证后面取出的元素在原数组中是最小的，这样其位置才能表示有多少比它大的数在它前面，即逆序对数。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-1"></a></span>
<span id="cb42-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-2"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb42-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-3"></a>class Solution<span class="op">:</span></span>
<span id="cb42-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-4"></a><span class="st">    </span>def <span class="kw">InversePairs</span>(self, data)<span class="op">:</span></span>
<span id="cb42-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-5"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb42-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-6"></a><span class="st">        </span>cnt =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb42-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-7"></a>        copy =<span class="st"> </span>data[<span class="op">:</span>]</span>
<span id="cb42-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-8"></a>        <span class="kw">copy.sort</span>()</span>
<span id="cb42-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-9"></a>        <span class="cf">for</span> i <span class="cf">in</span> copy<span class="op">:</span></span>
<span id="cb42-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-10"></a><span class="st">            </span>cnt <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="kw">data.index</span>(i)</span>
<span id="cb42-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-11"></a>            <span class="kw">data.remove</span>(i)</span>
<span id="cb42-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb42-12"></a>        return cnt%<span class="dv">1000000007</span></span></code></pre></div>
<p>思路2：归并排序
冒泡排序太暴力了</p>
<p>待我默写出来</p>
</div>
<div id="两个链表的第一个公共节点" class="section level2">
<h2><span class="header-section-number">2.18</span> 两个链表的第一个公共节点</h2>
<p><strong>题目描述</strong></p>
<p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<p>思路1
如果能从后面遍历两个链表，找到最后一个相同的节点，输出即可。可以利用两个栈来实现。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-1"></a><span class="co">#         self.next = None</span></span>
<span id="cb43-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-2"></a>class Solution<span class="op">:</span></span>
<span id="cb43-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-3"></a><span class="st">    </span>def <span class="kw">FindFirstCommonNode</span>(self, pHead1, pHead2)<span class="op">:</span></span>
<span id="cb43-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb43-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-5"></a><span class="st">        </span><span class="cf">if</span> pHead1<span class="op">==</span><span class="st"> </span>None or pHead2 <span class="op">==</span><span class="st"> </span>None<span class="op">:</span></span>
<span id="cb43-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-6"></a><span class="st">            </span>return None</span>
<span id="cb43-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-7"></a>        stack1 =<span class="st"> </span>[]</span>
<span id="cb43-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-8"></a>        stack2 =<span class="st"> </span>[]</span>
<span id="cb43-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-9"></a>        p1 =<span class="st"> </span>pHead1</span>
<span id="cb43-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-10"></a>        <span class="cf">while</span> p1 is not None<span class="op">:</span><span class="st">   </span><span class="co"># 依次将两个链表的所有节点分别压入两个栈中</span></span>
<span id="cb43-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-11"></a><span class="st">            </span><span class="kw">stack1.append</span>(p1)</span>
<span id="cb43-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-12"></a>            p1 =<span class="st"> </span>p1.next</span>
<span id="cb43-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-13"></a>        p2 =<span class="st"> </span>pHead2</span>
<span id="cb43-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-14"></a>        <span class="cf">while</span> p2 is not None<span class="op">:</span></span>
<span id="cb43-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-15"></a><span class="st">            </span><span class="kw">stack2.append</span>(p2)</span>
<span id="cb43-16"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-16"></a>            p2 =<span class="st"> </span>p2.next</span>
<span id="cb43-17"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-17"></a>        res =<span class="st"> </span>None</span>
<span id="cb43-18"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-18"></a>        <span class="cf">while</span> <span class="kw">len</span>(stack1) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> and <span class="kw">len</span>(stack2) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb43-19"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-19"></a><span class="st">        </span><span class="co"># 从后往前遍历，直到找到两个链表相同的最后一个节点，如果相同的话。</span></span>
<span id="cb43-20"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-20"></a><span class="st">            </span>v1 =<span class="st"> </span><span class="kw">stack1.pop</span>()</span>
<span id="cb43-21"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-21"></a>            v2 =<span class="st"> </span><span class="kw">stack2.pop</span>()</span>
<span id="cb43-22"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-22"></a>            <span class="cf">if</span> v1 <span class="op">==</span><span class="st"> </span>v2<span class="op">:</span></span>
<span id="cb43-23"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-23"></a><span class="st">                </span>res =<span class="st"> </span>v1</span>
<span id="cb43-24"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-24"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb43-25"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-25"></a><span class="st">                </span><span class="cf">break</span></span>
<span id="cb43-26"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb43-26"></a>        return res</span></code></pre></div>
<p>下面这个思路好骚啊~<a href="https://blog.csdn.net/ggdhs/article/details/90319403">csdn</a></p>
<p>感觉有点不懂</p>
<p><img src="figs/lbggjd.png" /></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb44-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-2"></a><span class="co"># class ListNode:</span></span>
<span id="cb44-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-3"></a><span class="co">#     def __init__(self, x):</span></span>
<span id="cb44-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-4"></a><span class="co">#         self.val = x</span></span>
<span id="cb44-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-5"></a><span class="co">#         self.next = None</span></span>
<span id="cb44-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-6"></a>class Solution<span class="op">:</span></span>
<span id="cb44-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-7"></a><span class="st">    </span>def <span class="kw">FindFirstCommonNode</span>(self, pHead1, pHead2)<span class="op">:</span></span>
<span id="cb44-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-8"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb44-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-9"></a><span class="st">        </span><span class="cf">if</span> pHead1<span class="op">==</span><span class="st"> </span>None or pHead2 <span class="op">==</span><span class="st"> </span>None<span class="op">:</span></span>
<span id="cb44-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-10"></a><span class="st">            </span>return None</span>
<span id="cb44-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-11"></a>        p1 =<span class="st"> </span>pHead1</span>
<span id="cb44-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-12"></a>        p2 =<span class="st"> </span>pHead2</span>
<span id="cb44-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-13"></a>        <span class="cf">while</span>(p1<span class="op">!=</span>p2)<span class="op">:</span><span class="st">  </span></span>
<span id="cb44-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-14"></a><span class="st">            </span>p1 =<span class="st"> </span>pHead2 <span class="cf">if</span> p1 is None <span class="cf">else</span> p1.next</span>
<span id="cb44-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-15"></a>            <span class="co"># 由于若pHead2是pHead1的最后一个节点，，因此不能以p1.next==None作为判断条件。</span></span>
<span id="cb44-16"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-16"></a>            <span class="co"># 否则就会死循环。</span></span>
<span id="cb44-17"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-17"></a>            p2 =<span class="st"> </span>pHead1 <span class="cf">if</span> p2 is None <span class="cf">else</span> p2.next</span>
<span id="cb44-18"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb44-18"></a>        return p1</span></code></pre></div>
</div>
<div id="数字在升序数组中出现的次数" class="section level2">
<h2><span class="header-section-number">2.19</span> 数字在升序数组中出现的次数</h2>
<p><strong>题目描述</strong></p>
<p>统计一个数字在升序数组中出现的次数。</p>
<p>怎么写都能通过吧</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb45-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-2"></a>class Solution<span class="op">:</span></span>
<span id="cb45-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-3"></a><span class="st">    </span>def <span class="kw">GetNumberOfK</span>(self, data, k)<span class="op">:</span></span>
<span id="cb45-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb45-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-5"></a><span class="st">        </span>count =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb45-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-6"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(data))<span class="op">:</span></span>
<span id="cb45-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-7"></a><span class="st">            </span><span class="cf">if</span>(data[i] <span class="op">==</span><span class="st"> </span>k)<span class="op">:</span></span>
<span id="cb45-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-8"></a><span class="st">                </span>count <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb45-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-9"></a>        return count</span>
<span id="cb45-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-10"></a>        <span class="co"># 或者就直接用python的count函数</span></span>
<span id="cb45-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb45-11"></a>        <span class="co"># return data.count(k)</span></span></code></pre></div>
</div>
<div id="平衡二叉树" class="section level2">
<h2><span class="header-section-number">2.20</span> 平衡二叉树</h2>
<p><strong>题目描述</strong>
输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p>
<p>首先啊得了解啥是平衡二叉树</p>
<p><strong>一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值小于1。</strong></p>
<p>大于1就返回fasle呗</p>
</div>
<div id="数组中只出现一次的数" class="section level2">
<h2><span class="header-section-number">2.21</span> 数组中只出现一次的数</h2>
<p><strong>题目描述</strong>
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb46-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-2"></a>class Solution<span class="op">:</span></span>
<span id="cb46-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-3"></a><span class="st">    </span><span class="co"># 返回[a,b] 其中ab是出现一次的两个数字</span></span>
<span id="cb46-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-4"></a><span class="st">    </span>def <span class="kw">FindNumsAppearOnce</span>(self, array)<span class="op">:</span></span>
<span id="cb46-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-5"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb46-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-6"></a><span class="st">        </span>res=[]</span>
<span id="cb46-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-7"></a>        <span class="cf">for</span> i <span class="cf">in</span> array<span class="op">:</span></span>
<span id="cb46-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-8"></a><span class="st">            </span><span class="cf">if</span> <span class="kw">array.count</span>(i)<span class="op">==</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb46-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-9"></a><span class="st">                </span><span class="kw">res.append</span>(i)</span>
<span id="cb46-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb46-10"></a>        return res</span></code></pre></div>
</div>
<div id="和为s的连续子序列" class="section level2">
<h2><span class="header-section-number">2.22</span> 和为S的连续子序列</h2>
<p><strong>题目描述</strong></p>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<p><strong>思路1</strong>
在连续的正数序列中，如果一个数比和的一半要大的话，如和为100，其中一个数是51，那么，存在51且和等于100的这个序列是不存在的。因此，我们可以借助两个循环，来循环遍历所有和等于tsum的序列。</p>
<p>也就是穷举法</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb47-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-2"></a>class Solution<span class="op">:</span></span>
<span id="cb47-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-3"></a><span class="st">    </span>def <span class="kw">FindContinuousSequence</span>(self, tsum)<span class="op">:</span></span>
<span id="cb47-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb47-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-5"></a><span class="st">        </span>res =<span class="st"> </span>[]</span>
<span id="cb47-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-6"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>, tsum<span class="op">/</span><span class="er">/</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span>)<span class="op">:</span><span class="st"> </span>遍历一半就行了</span>
<span id="cb47-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-7"></a>            sum =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb47-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-8"></a>            <span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(i, tsum<span class="op">/</span><span class="er">/</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span>)<span class="op">:</span></span>
<span id="cb47-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-9"></a><span class="st">                </span>sum <span class="op">+</span><span class="er">=</span><span class="st"> </span>j</span>
<span id="cb47-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-10"></a>                <span class="cf">if</span> sum <span class="op">==</span><span class="st"> </span>tsum<span class="op">:</span></span>
<span id="cb47-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-11"></a><span class="st">                    </span><span class="kw">res.append</span>(<span class="kw">list</span>(<span class="kw">range</span>(i, j<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb47-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-12"></a>                <span class="cf">if</span> sum <span class="op">&gt;</span><span class="st"> </span>tsum<span class="op">:</span></span>
<span id="cb47-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-13"></a><span class="st">                    </span><span class="cf">break</span></span>
<span id="cb47-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb47-14"></a>        return res</span></code></pre></div>
<p><em>思路2</em></p>
<blockquote>
<p>利用一个双指针来实现一个滑动窗口，如果当前窗口内的和等于tsum，返回窗口内的所有数，并且移动窗口，窗口右侧向右移动一位或者左侧右移一位都行，如果小于tsum的话，窗口的左侧向右移动一位，如果大于tsum的话，窗口的右侧向左移动一位，循环终止条件是，窗口左侧，即（窗口左侧）序列的最小值大于tsum//2，即思路1中的不会有数大于和的一半。<a href="https://blog.csdn.net/ggdhs/article/details/90344263">csdn</a></p>
</blockquote>
<p>滑动窗口的思想真的挺常见的，要熟练使用哇</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb48-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-2"></a>class Solution<span class="op">:</span></span>
<span id="cb48-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-3"></a><span class="st">    </span>def <span class="kw">FindContinuousSequence</span>(self, tsum)<span class="op">:</span></span>
<span id="cb48-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb48-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-5"></a><span class="st">        </span><span class="cf">if</span> tsum <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb48-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-6"></a><span class="st">            </span>return []</span>
<span id="cb48-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-7"></a>        small =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb48-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-8"></a>        big =<span class="st"> </span><span class="dv">2</span></span>
<span id="cb48-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-9"></a>        mid =<span class="st"> </span>tsum<span class="op">/</span><span class="er">/</span><span class="dv">2</span></span>
<span id="cb48-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-10"></a>        sum =<span class="st"> </span>big<span class="op">+</span>small       <span class="co"># 用来不断更新当前序列的和，也可以利用求和公式。</span></span>
<span id="cb48-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-11"></a>        ret =<span class="st"> </span>[]</span>
<span id="cb48-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-12"></a>        <span class="cf">while</span> small <span class="op">&lt;=</span><span class="st"> </span>mid<span class="op">:</span></span>
<span id="cb48-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-13"></a><span class="st">            </span><span class="cf">if</span> sum <span class="op">==</span><span class="st"> </span>tsum<span class="op">:</span></span>
<span id="cb48-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-14"></a><span class="st">                </span><span class="kw">ret.append</span>(<span class="kw">list</span>(<span class="kw">range</span>(small,big<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb48-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-15"></a>                big <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span>       <span class="co"># 如果右侧窗口移动，先移动在加</span></span>
<span id="cb48-16"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-16"></a>                sum <span class="op">+</span><span class="er">=</span><span class="st"> </span>big     <span class="co"># 不断更新，也可以利用求和公式来计算窗口内数的和</span></span>
<span id="cb48-17"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-17"></a>            elif sum <span class="op">&lt;</span><span class="st"> </span>tsum<span class="op">:</span></span>
<span id="cb48-18"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-18"></a><span class="st">                </span>big <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span>      </span>
<span id="cb48-19"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-19"></a>                sum <span class="op">+</span><span class="er">=</span><span class="st"> </span>big</span>
<span id="cb48-20"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-20"></a>            <span class="cf">else</span><span class="op">:</span><span class="st">             </span><span class="co"># 如果左侧窗口移动，先减在移动</span></span>
<span id="cb48-21"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-21"></a><span class="st">                </span>sum <span class="op">-</span><span class="er">=</span><span class="st"> </span>small</span>
<span id="cb48-22"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-22"></a>                small <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb48-23"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb48-23"></a>        return ret</span></code></pre></div>
</div>
<div id="两个数之和为s" class="section level2">
<h2><span class="header-section-number">2.23</span> 两个数之和为s</h2>
<p><strong>题目描述</strong>
输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>easy题</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-1"></a><span class="co"># -*- coding:utf-8 -*-</span></span>
<span id="cb49-2"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-2"></a>class Solution<span class="op">:</span></span>
<span id="cb49-3"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-3"></a><span class="st">    </span>def <span class="kw">FindNumbersWithSum</span>(self, array, tsum)<span class="op">:</span></span>
<span id="cb49-4"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb49-5"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-5"></a><span class="st">        </span><span class="cf">if</span> not array or not tsum<span class="op">:</span></span>
<span id="cb49-6"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-6"></a><span class="st">            </span>return []</span>
<span id="cb49-7"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-7"></a>        result =<span class="st"> </span>[]</span>
<span id="cb49-8"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-8"></a>        <span class="cf">for</span> i <span class="cf">in</span> array<span class="op">:</span></span>
<span id="cb49-9"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-9"></a><span class="st">            </span><span class="cf">if</span> (tsum <span class="op">-</span><span class="st"> </span>i) <span class="cf">in</span> array<span class="op">:</span></span>
<span id="cb49-10"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-10"></a><span class="st">                </span><span class="kw">result.append</span>([i, tsum <span class="op">-</span><span class="st"> </span>i])</span>
<span id="cb49-11"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-11"></a>        <span class="cf">if</span> result<span class="op">:</span></span>
<span id="cb49-12"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-12"></a><span class="st">            </span><span class="kw">result.sort</span>(<span class="dt">key=</span>lambda x<span class="op">:</span><span class="st"> </span>x[<span class="dv">0</span>] <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>])</span>
<span id="cb49-13"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-13"></a>            result =<span class="st"> </span>result[<span class="dv">0</span>]</span>
<span id="cb49-14"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-14"></a>            return result</span>
<span id="cb49-15"><a href="感觉例子看的有点晕糊栈的存储原则是后进先出.html#cb49-15"></a>        return []</span></code></pre></div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="剑指offer题解.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page"><i class="fa fa-angle-left"></i></a>

    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
