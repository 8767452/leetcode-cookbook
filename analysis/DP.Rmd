动态规划问题

**解题思路**：状态定义，转移方程，初始条件，返回值

### 买卖股票的最佳时机

买股票的的价格不能低于买股票的，这是一个约束条件

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

 
示例 1:

输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

```r
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        inf = int(1e9)
        minprice = inf  #用一个值来维护历史最低价格
        maxprofit = 0 #利润不能小于0
        for price in prices:
            maxprofit = max(price - minprice, maxprofit)
            minprice = min(price, minprice)
        return maxprofit
```

### 爬楼梯问题

斐波那契数列：只需要考虑最后到达最后一阶实现的几种情况

题目一般有2种，可以爬2阶或者3阶，思路一样，递归+DP，但是要注意时间复杂度。。

### 最大子序和问题

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。


动态规划的入门篇的题

```r
class Solution:
    def maxSubArray(self,nums:List[int])->int:
        if len(nums)==0:
            return 0
        if len(nums)==1:
            range nums[0]

        res=nums[0]
        for i in range(1,len(nums)):
            nums[i]=max(nums[i],nums[i]+nums[-1])

            res=max(res,num[i])
        return res
```

### 偷钱问题

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。


```r
class Solution:
    def rob(self, nums: List[int]) -> int:
       prev = 0
       curr = 0
    
     # 每次循环，计算“偷到当前房子为止的最大金额”
       for i in nums:
        # 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]
        # dp[k] = max{ dp[k-1], dp[k-2] + i }
           prev, curr = curr, max(curr, prev + i)
        # 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]

       return curr

```

### 比特位计数

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]  ** 返回0，1，2三个数的二进制种的1的数目**
示例 2:

输入: 5
输出: [0,1,1,2,1,2]




对于所有的数字，只有两类：

奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
          举例： 
         0 = 0       1 = 1
         2 = 10      3 = 11
偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。
           举例：
          2 = 10       4 = 100       8 = 1000
          3 = 11       6 = 110       12 = 1100
另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。


```r
class Solution:
    def countBits(self, num: int) -> List[int]:
        ret = [0, 1, 1]
        for n in range(3, num+1):
            ret.append(ret[-1]+1) if n & 1 == 1 else ret.append(ret[n//2])
        return ret[0:num+1]
```

### 最短路径和问题

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。



![最短路径和的问题](figs/最短路径和的问题.png)
二维的动态规划

i横向,j纵向
```r
class Solution:
    def minPathSum(self, grid: [[int]]) -> int:
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == j == 0: continue
                elif i == 0:  grid[i][j] = grid[i][j - 1] + grid[i][j]
                elif j == 0:  grid[i][j] = grid[i - 1][j] + grid[i][j]
                else: grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j]
        return grid[-1][-1]
```

### 回文字符串

这个之前参加某个笔试遇到了

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"

解题思路
![最长回文字符串](figs/最长回文字符串.png)


```r
class Solution:
    def longestPalindrome(self, s: str) -> str:
        #dp[i][j] = true,if s[i] = s[j]
        #dp[0][len(s)-1]
        length = len(s)
        dp = [[0] * length for _ in range(len(s))]
        res = 0, 0 #长度为1时
        for i in range(1, length):
             for j in range(length-i):
                if s[j] == s[j+i] and (j+1 >= j+i-1 or dp[j+1][j+i-1]):
                    dp[j][j+i] = 1 
                    res = j, j+i
        left, right = res
        return s[left: right+1]

```

动态规划问题解题思路

![动态规划问题解题思路](figs/动态规划问题解题思路.png)

