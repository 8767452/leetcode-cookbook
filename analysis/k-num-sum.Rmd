## 前缀

使用前缀数组的一大好处是可用 pre(b) - pre(a-1) 来表示 a->b 中这段中数组的和。这个 a-1 可以不用那么纠结。重点理解思想。

比如 前5项的和 - 前3项的和 = 第4项~第5项的和。 (1+2+3+4+5) - (1+2+3) = 4+5

或者说 pre(b) - pre(a) 等同于 a+1~b 的和。这样子更好理解一些。



### K数之和

给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
说明 :

数组的长度为 [1, 20,000]。
数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。



这个方法会超时，比较暴力，但是好想
```r
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        cnt, n =  0, len(nums)
        for i in range(n):
            for j in range(i, n):
                if (sum(nums[i:j + 1]) == k): cnt += 1
        return cnt

```

**前缀和的思想**

num_times存储的是某一个前缀和出现的次数，但是由于我们在动态遍历 nums 并对 num_times 这个字典的值进行更新，所以每到一个新位置我们看到的都是到当前这个新位置为止，前面的某个前缀和出现的次数。比如我们到某一个位置 i 得到前缀和为 9，也就说从 0 位置到 i 位置的所有数字的和为 9， 如果目标 k 为 3，那么我们只需要找到当前状态下，前面出现了几次 6，就知道以 nums[i] 结尾的和为 3 的连续子数组的个数有多少个。建议大家动手在草纸上演算一下这个过程，看一下各个变量在这个过程中的变化，慢慢捋顺就好懂了(因为前缀和的做法第一次接触真的是非常不容易懂)

```r
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        # num_times 存储某“前缀和”出现的次数，这里用collections.defaultdict来定义它
        # 如果某前缀不在此字典中，那么它对应的次数为0
        num_times = collections.defaultdict(int)
        num_times[0] = 1  # 先给定一个初始值，代表前缀和为0的出现了一次
        cur_sum = 0  # 记录到当前位置的前缀和
        res = 0
        for i in range(len(nums)):
            cur_sum += nums[i]  # 计算当前前缀和
            if cur_sum - k in num_times:  # 如果前缀和减去目标值k所得到的值在字典中出现，即当前位置前缀和减去之前某一位的前缀和等于目标值
                res += num_times[cur_sum - k]
            # 下面一句实际上对应两种情况，一种是某cur_sum之前出现过（直接在原来出现的次数上+1即可），
            # 另一种是某cur_sum没出现过（理论上应该设为1，但是因为此处用defaultdict存储，如果cur_sum这个key不存在将返回默认的int，也就是0）
            # 返回0加上1和直接将其置为1是一样的效果。所以这里统一用一句话包含上述两种情况
            num_times[cur_sum] += 1
        return res

```

