## 哈希表

python中的字典的原理



**前缀**

使用前缀数组的一大好处是可用 pre(b) - pre(a-1) 来表示 a->b 中这段中数组的和。这个 a-1 可以不用那么纠结。重点理解思想。

比如 前5项的和 - 前3项的和 = 第4项~第5项的和。 (1+2+3+4+5) - (1+2+3) = 4+5

这个前缀和数组 preSum 的含义也很好理解，preSum[i] 就是 nums[0..i-1] 的和。那么如果我们想求 nums[i..j] 的和，只需要一步操作 preSum[j+1]-preSum[i] 即可，而不需要重新去遍历数组了。

### K数之和

给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
说明 :

数组的长度为 [1, 20,000]。
数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。



这道题刚开始想到的思路是，先利用dp数组存放前i个数的和（前缀和），然后遍历这个数组，对于每个元素，求出dp[i]+k在dp[i:]的存在个数，即为以i+1开头的符合条件的子数组的个数，遍历结束把每个点的个数加在一起，即为答案。

分析可知，这种方法除了开始生成dp遍历了一次数组，在后面使用了双层循环，时间复杂度O(N^2)，空间复杂度O(N)。

这种方法可以通过，但是耗时太多，那么，如果对时间复杂度进行优化呢。

==

使用哈希表（Python中字典原理）即可。抛弃dp数组，**只使用一个变量pre来保存当前位置的前缀和，使用一个字典dp，它的key是前缀和的值，对应的value表示这个前缀和出现的次数。**

在元素累加的过程中得到sum[j]=nums[0]+nums[1]+···+nums[j]，并放入哈希表中。如果我们可以在哈希表中发现之前存在着sum[i]使得sum[j]-sum[i]=k，那么也就说明了有一个子序列之和为 k。时间复杂度终于被降到了$O(n)$。

首先添加dp[0] = 1，表示前缀和为0的情况出现了一次(这是为了考虑从i=0开始的答案)，之后遍历数组，计算前缀和pre，加入dp（要判断pre是否存在，不存在写入，存在dp[pre]+=1)，同时判断pre-k是否在dp字典中，如果在，ans+=dp[pre-k]，说明存在dp[pre-k]种答案。最后返回ans即可。

。
这种情况只遍历了一次数组，字典中找值的过程时间复杂度O(1)，所以总的时间复杂度O(N)，只用到了一个变量和字典，空间复杂度O(N)。

```r
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        pre = 0 #前缀和
        ans = 0
        dp = dict() #存放 前缀和:出现次数，键值对，初始化一个0:1，为了考虑到从头开始到某点的子数组正好为答案。
        dp[0] = 1
        for i in range(n):
            pre += nums[i] #计算前缀和
            if pre-k in dp: #如果pre-k这个前缀存在，那么答案加上它出现的次数
                ans += dp[pre-k]
            if pre in dp: #更新dp[pre]
                dp[pre] += 1
            else:
                dp[pre] = 1
        return ans
```

## 贪心算法

### 跳跃游戏

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

示例 2:

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。

- 如果所有元素都不为0， 那么一定可以跳到最后；
- 从后往前开始想，如果这个节点能够达到，那么下一个节点只要大于等于1就行，如果这个节点不能达到那么那么期待下一个节点要大于等于能达到的距离

可以用贪心的方法解决这个问题。

![跳跃游戏](figs/跳跃游戏.png)

```r
class Solution:
    def canJump(self, nums) :
        max_i = 0       #初始化当前能到达最远的位置
        for i, jump in enumerate(nums):   #i为当前位置，jump是当前位置的跳数
            if max_i>=i and i+jump>max_i:  #如果当前位置能到达，并且当前位置+跳数>最远位置  
                max_i = i+jump  #更新最远能到达位置
        return max_i>=i

```

时间复杂度：O(n)，其中 n 为数组的大小。只需要访问 nums 数组一遍，共n 个位置。

空间复杂度：O(1)，不需要额外的空间开销。


