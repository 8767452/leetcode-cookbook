---
title: "剑指offer"
author: "wenxin Gao"
date: "2020/8/10"
output: html_document
---

# 剑指offer题解

安装牛客网的顺序的来的~


## 二维数组中的查找

**题目描述**
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。


思路：最先想到的遍历一遍数组，判断target是否在数组中即可

```r

class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        for arr in array:
            if target in arr:
                return True
        return False
```

## 替换空格

**题目描述**
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

思路:

最先能想到replace，哈哈~直接替换

```r
# -*- coding:utf-8 -*-
import re
class Solution:
    # s 源字符串
    def replaceSpace(self, s):
        # write code here
        return s.replace(' ','%20')
```


## 从头到尾打印链表

**题目描述**

输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

从尾到头的顺序，第一个感觉是reverse，但是感觉这么写会被打~

还是一样的问题：有几天

```r

# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        res = []
        while listNode:
            
            res.append(listNode.val)
            listNode = listNode.next
        return res[::-1]

```

## 重建二叉树

**题目描述**

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。



**思路**:递归加迭代

知识点：

前序遍历列表：第一个元素永远是 【根节点 (root)】
中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】

算法思路：

通过【前序遍历列表】确定【根节点 (root)】
将【中序遍历列表】的节点分割成【左分支节点】和【右分支节点】
递归寻找【左分支节点】中的【根节点 (left child)】和 【右分支节点】中的【根节点 (right child)】

就是在考察前序中序后序树的遍历顺序:前序第一个是根节点，找到根节点在中序中的位置，可以划分左右子树，然后递归即可

```r
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if len(inorder) == 0:
            return None
        
        # 根节点
        root = TreeNode(preorder[0]) #前序遍历找根节点~
        # 获取根节点在 inorder 中的索引
        idx = inorder.index(preorder[0]) # 找到根节点的索引
        # 左子树
        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx]) # 
        # 右子树
        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])
        return root

```

## 两个栈实现队列

栈：先进后厨
队列：先进先出

**题目描述**

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

找个主要如果用牛客的话需要自己先定义两个空队列

```r
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def push(self, node):
        # write code here
        self.stack1.append(node)
    def pop(self):
        # return xx
        if len(self.stack2) == 0: # 第二个是空队列哦
            while len(self.stack1) !=0:
                self.stack2.append(self.stack1[len(self.stack1)-1]) # 先进先出
                self.stack1.pop()
        pop = self.stack2[len(self.stack1)-1]
        self.stack2.pop()
        return pop
```



## 旋转数组中最小的数

**题目描述**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

思路：第一感觉，一个min函数不就完事了，但是这么写没有意义，面试官会说你把min的底层写出来~

呵呵 了

因此肯定考排序这里的，比如二分法查找~

保证rotateArray[left]为全场最小，当rotateArray[left]<rotateArray[right]时，证明进入了有序数组，直接输出

```r
# -*- coding:utf-8 -*-
class Solution:
    def minNumberInRotateArray(self, rotateArray,):
        # write code here
        if len(rotateArray) == 0:
            return 0
        # 二分法查找,快排
        left = 0
        right = len(rotateArray)-1
        while left<right: #从左向右开始遍历
            if rotateArray[left]<rotateArray[right]:
                return rotateArray[left]
            mid = left + (right -left)//2
            # 左边 有序取另一半
            
            if rotateArray[left]<rotateArray[mid]:
                left = mid +1
            # 右边有序右边取最小
            elif rotateArray[mid]<rotateArray[right]:
                right = mid
             #前面两个相等的时候，left进一继续
            else :
                left+=1
        return rotateArray[left]
```

## 斐波那契数列

**题目描述**
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。
n<=39

直接给出动态规划的解法，省内存

```r

# -*- coding:utf-8 -*-
class Solution:
    def Fibonacci(self, n):
        # write code here
        num = {}
        num[0] = 0
        num[1] = 1
        if n > 1:
            for i in range(2,n+1):
                num[i] = num[i-2] + num[i-1]
        return int(num[n]%(1000000007))

# 绝了，一开始最后的结果没除1000000007取余，死活通不过
```

## 青蛙跳台阶问题

**题目描述**
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

```r
class Solution:
    def jumpFloor(self, number):
        # write code here
        if number==1:
            return 1
        res=[1,2]
        for i in range(2,number):
            res.append(res[i-1]+res[i-2])
        return res[-1]
```


## 变态跳台问题

加强版

**题目描述**

一只青蛙一次可以跳上1级台阶，也可以跳上2级……*它也可以跳上n级*。求该青蛙跳上一个n级的台阶总共有多少种跳法。

一般**递归**能解决大部分的问题

易知 f(n)=f(n-1)+f(n-2)+……f(1)
f(n-1)=f(n-2)+……f(1)
两式相减得f(n)=2f(n-1)

```r
class Solution:
    def jumpFloorII(self, number):
        # write code here
        n=1 
        for i in range(2,number+1):
            n=2*n
        return n
        
```


## 矩形覆盖

**题目描述**
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

![](figs/jxfg.png)

思想：和跳台阶类似，小矩形竖着放相当于跳一级台阶，横着放相当于跳两级台阶，所以可以复用跳台阶的代码（见第八题）。


```r
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloor(self, number):
        # write code here
        if number == 0:
            return 0
        res = [0,1,2]
        for i in range(3,number+1):
            res.append(res[i-1]+res[i-2])
        return res[number]
        
```

## 二进制中的1的个数

**题目描述**
输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。

其实我jio的一行就行了，bin+count,但是牛客不给通过

```r

#class Solution:
    
   def NumberOf1(self, n):
        # write code here
        
       return bin(n).count('1')
```

还是得用正常的方式
```r
class Solution:
    def NumberOf1(self, n):
        # write code here
        count = 0
        if n < 0:
            n = n & 0xffffffff
        while n:
                count += 1
                n = (n - 1) & n
        return count
        
```
## 数值得整熟次方

**题目描述**

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0

实现底层得pow，限制条件多，但是不难得，京东一面其中一个算法题

```r
# -*- coding:utf-8 -*-
class Solution:
    def Power(self, base, exponent):
        # write code here
        temp = base
        # 0的0次方和0的负数次方无意义
        if base == 0.0 and exponent <= 0:
            return None
        #0的次方为0
        if base == 0.0 :
            return 0
        #除0以外的任何数的0次方都为0
        if exponent == 0:
            return 1
        #负数次方时
        if exponent < 0:
            for i in range(-exponent-1):
                base *= temp
            return 1.0 / base
        else:
            #正数次方时
            for i in range(exponent-1):
                base *= temp
            return base
```


今天贝壳找房得笔试挂了，因此多来三个题平复下心情~

算法虐我千百遍我待算法如初恋~


## 调整数组顺序使其位于整熟前面

**题目描述**

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。


给一个常规得解法

```r
class Solution:
    def reOrderArray(self, array):
        # write code here
        j=[]
        o=[]
        for i in array:
            if i%2==0:
                o.append(i)
            else:
                j.append(i)
        return j+o
        
```

## 链表的倒数第k个节点

题目描述
输入一个链表，输出该链表中倒数第k个结点。

用一个最直观的方法，时间复杂度为o（k)

```r

class Solution:
    def FindKthToTail(self, head, k):
        # write code here
        #哎，你就把链表当一个list去遍历呗,只是向下移动的方式是不一样的
        res=[]
        while head:
            res.append(head)
            head=head.next
        if k>len(res) or k<1:
            return 
        return res[-k]
        
```


## 反转链表

**题目描述**
输入一个链表，反转链表后，输出新链表的表头。

自己画个图就非常的明白了


```r
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        
        p = None
        while pHead:
            curr=pHead
            pHead=pHead.next
            curr.next=p
            p=curr
        return p
```

突然发现，今天笔试题不会的原因是因为，比较重要的5个排序没有学透！！


## 合并两个有序链表

**题目描述**
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

```r

class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        # write code here
        if not pHead1:
            return pHead2
        if not pHead2:
            return pHead1
        if pHead1.val<pHead2.val:
            pHead1.next = self.Merge(pHead1.next,pHead2)
            return pHead1
        else:
            pHead2.next = self.Merge(pHead1,pHead2.next)
            return pHead2
```

## 树的子结构

**题目描述**

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

把树看作一个链表的问题呗






## 二叉树的镜像

题目描述
操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述:
二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
    	
    	
思路：观察镜像的特点即可

```r
# -*- coding:utf-8 -*-
class TreeNode:
     def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
 
class Solution:
    # 返回镜像树的根节点
    def Mirror(self, root):
        # write code here
        if not root:
            return 
        root.left,root.right =root.right,root.left
        self.Mirror(root.left)
        self.Mirror(root.right)
        return root
```

## 顺时针打印矩阵

**题目描述**
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.


可以考虑画个图，完事就会想到：每次只取第一行数据，然后再把矩阵逆时针旋转90度

```r

class Solution:
    #每次只取第一行数据，然后再把矩阵逆时针旋转90度
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        # write code here
        res = []
        while matrix:
            res += matrix.pop(0)
            matrix = list(zip(*matrix))[::-1] #这个转置矩阵的好骚啊！
        return res
```

## 包含min函数的栈

**题目描述**

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)。


```r
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.arr=[]
    def push(self, node):
        # write code here
        self.arr.append(node)
    def pop(self):
        # write code here
        return self.arr.pop()
    def top(self):
        return self.arr[-1]
    def min(self):
        # write code here
        return min(self.arr)
```

## 栈的压入和弹出顺序

**题目描述**

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

思路：题没读明白，直接看的解析

>'''
首先找到这个规律，判断顺序是否正确，必须先将压入序列全部遍历后，才能进行判断，
即判断的永远是出栈序列的最后两个。
然后就有方法，先将push序列依次压入栈，并判断栈顶元素是否和弹出序列pop的首位相同，
如果相同，则弹出该元素，并且pop首位加一，作为下一个判断位置。如果不相同，则push继续压入。
如果push全部压入，表明这时的弹出顺序已经确定。这时候判断弹出序列pop的首位和栈顶元素是否相同，
不相同，则表明该序列为假。如果全部判断都相同，就为真。

'''

# 感觉例子看的有点晕糊，栈的存储原则是后进先出


```r
class Solution:
    def IsPopOrder(self, pushV, popV):
        # write code here
        stack=[]
        while popV:
            ##如果stack的最后一个元素与popV中第一个元素相等，将两个元素都弹出
            if stack and stack[-1]==popV[0]:
                stack.pop()
                popV.pop(0)
            # 如果pushV中有数据，压入stack
            elif pushV:
                stack.append(pushV.pop(0))
            # 上面情况都不满足，直接返回false。
            else:
                return False
        return True
        
```
## 最小的K个数

**题目描述**
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

```r
class Solution:
    def GetLeastNumbers_Solution(self, tinput, k):
        # write code here
        if tinput==[] or k>len(tinput):
            return []
        tinput.sort()
        return tinput[:k]
```

## 最大子序和

**题目描述**
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

典型的动态规划

```r
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        # write code here
        n=len(array)
        if not array:
            return 
        if len(array)==1:
            return array[-1]
        dp=[0]*n
        dp[0]=array[0]
        for i in range(1,n):
            dp[i]=max(dp[i-1]+array[i],array[i])
        return max(dp)
```

## 数组中出现次数超过一半的数字


**题目描述**
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

给出两种解法

```r

# 数量超过数组长度一半的数字排序后必定占据中间位置
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        # write code here
        numbers.sort()
        theone = numbers[len(numbers)/2]
        if numbers.count(theone) > len(numbers)/2:
            return theone
        return  0
```
```r
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        # write code here
        A = {}
        for i in numbers:
            if i in A:
                A[i] += 1
            else:
                A[i] = 1
        maxnum = max(A.values())
        print(maxnum)
        if 2*maxnum > len(numbers):
            return [k for k,v in A.items() if v== max(A.values())][0]
        else:
            return 0
```

## 字符串的排序

**题目描述**
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
输入描述:
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

先给一个能调包做的


**b站笔试题**

## 有效的括号

题目描述：

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true

知识点：栈

**解题思路**
当开始接触题目时，我们会不禁想到如果计算出左括号的数量，和右括号的数量，如果每种括号左右数量相同, 会不会就是有效的括号了呢?
事实上不是的，假如输入是 [ (] ) ，每种括号的左右数量分别相等, 但不是有效的括号。这是因为结果还与括号 的位置有关。
仔细分析我们发现，对于有效的括号, 它的部分子表达式仍然是有效的括号, 比如 $\quad\{()[()]\}$ 是一个有效的括 号, $\quad()[\{\}]$ 是有效的括号, $\quad[()]$ 也是有效的括号。并且当我们**每次删除一个最小的括号对时，我们会逐渐将 括号删除完**。比如下面的例子。

![](figs/khao.png)

这个思考的过程其实就是栈的实现过程。因此我们考虑使用栈，当遇到匹配的最小括号对时，我们将这对括号从栈中删除（即出栈），如果最后栈为空，那么它是有效的括号，反之不是。

代码中我们使用了哈希表来判断是否能够形成括号，从而决定进行入栈操作还是出栈操作。[leetcode](https://leetcode-cn.com/problems/valid-parentheses/solution/zhu-bu-fen-xi-tu-jie-zhan-zhan-shi-zui-biao-zhun-d/)


- 使用栈，是左括号代表入栈，是右括号代表出栈
- 如果要出栈，出栈的元素要与当前元素匹配
- 最终栈要为空


```r
class Solution:
    def isValid(self, s: str) -> bool:
        stack=[]                            #设置一个列表，把该列表当做栈来使用即可。
        dic={')':'(','}':'{',']':'['}       #使用字典存储括号,并且右括号为key,左括号为value
        for char in s:
            if char in dic.values():        #左括号就入栈
                stack.append(char)
            elif char in dic.keys():        #有右括号的话就进行比较，
                if stack==[] or dic[char] != stack.pop():
                    return False
            else:
                return False                #不再字典中的输入直接输出错误

        return stack==[]

```

一个比较骚的题解

```r
class Solution:
    def isValid(self, s):
        while '{}' in s or '()' in s or '[]' in s:
            s = s.replace('{}', '')
            s = s.replace('[]', '')
            s = s.replace('()', '')
        return s == ''
```


## 找零

链接：https://www.nowcoder.com/questionTerminal/944e5ca0ea88471fbfa73061ebe95728
来源：牛客网

Z国的货币系统包含面值1元、4元、16元、64元共计4种硬币，以及面值1024元的纸币。现在小Y使用1024元的纸币购买了一件价值为N (0 < N \le 1024)N(0<N≤1024)的商品，请问最少他会收到多少硬币？

也就是买柠檬水找钱的问题

```r
def zl(n):
    coins=[1,4,16,64]
    
    s=1024-n+1
    dp=[1024]*(s)
    dp[0]=0
    for i in range(1,s):
        for c in coins:
            if i-c>=0:
                dp[i]=min(dp[i-c]+1,dp[i])
                
    return dp[-1]
```


## 24点游戏

你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。

示例 1:

输入: [4, 1, 8, 7]
输出: True
解释: (8-4) * (7-1) = 24
示例 2:

输入: [1, 2, 1, 2]
输出: False

注意:

除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。
每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。
你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。


>四个数取出两个数之后,做加减乘除处理之后加入到原数组中会剩下三个数,递归交给下一层去处理[akari-5](https://leetcode-cn.com/problems/24-game/solution/python-dfsdi-gui-by-akari-5/)


```r
class Solution:
    def judgePoint24(self, nums: List[int]) -> bool:
        if not nums: return False
        def helper(nums):
            if len(nums) == 1: return abs(nums[0]-24) < 1e-6
            for i in range(len(nums)):
                for j in range(len(nums)):
                    if i != j:
                        newnums = [nums[k] for k in range(len(nums)) if i != k != j]
                        if helper(newnums + [nums[i]+nums[j]]): return True
                        if helper(newnums + [nums[i]-nums[j]]): return True
                        if helper(newnums + [nums[i]*nums[j]]): return True
                        if nums[j] != 0 and helper(newnums + [nums[i]/nums[j]]): return True
            return False
        return helper(nums)
```

## 从上到下打印二叉树

**题目描述**
从上往下打印出二叉树的每个节点，同层节点从左至右打印。

思路：二叉树的层次遍历,一层一层遍历完继续下一层



```r
# -*- coding:utf-8 -*-
# class TreeNode:
def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # 返回从上到下每个节点值列表，例：[1,2,3]
    def PrintFromTopToBottom(self, root):
        # write code here
        #
        if not root:
            return ''
        
        que=[root] #根节点保存在队列中
        res=[] #用一个list保存输出值
        while que:
            if que[0].left:
                que.append(que[0].left)
            if que[0].right:
                que.append(que[0].right)
            res.append(que[0].val)
            que.pop(0) #遍历完一个根和左右就删掉
        return res
        
```


## 二叉树的后续遍历

**题目描述**
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。

- 后序遍历的序列中，最后一个数字是树的根节点 ，
- 数组中前面的数字可以分为两部分：第一部分是左子树节点的值，都比根节点的值小；
- 第二部分 是右子树节点的值，都比根节点的值大，
- 后面用递归分别判断前后两部分 是否符合以上原则。


```r
# -*- coding:utf-8 -*-
class Solution:
    def VerifySquenceOfBST(self, sequence):
        # write code here
        
        if sequence==None or len(sequence)==0:
            return False
        length=len(sequence)
        root=sequence[length-1]
        # 在二叉搜索树中 左子树节点小于根节点
        for i in range(length):
            if sequence[i]>root:
                break
        # 二叉搜索树中右子树的节点都大于根节点
        for j in range(i,length):
            if sequence[j]<root:
                return False
        # 判断左子树是否为二叉树
        left=True
        if i>0:
            left=self.VerifySquenceOfBST(sequence[0:i])
        # 判断 右子树是否为二叉树
        right=True
        if i<length-1:
            right=self.VerifySquenceOfBST(sequence[i:-1])
        return left and right
```

## 二叉树中和为某一路径值

**题目描述**

输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

```r
思路是递归：递归方法是返回当前路径下匹配目标值的路径。
目标值 = 目标值 - 当前节点值
共有几种情况：
0，当节点为空，return
1，当目标值小于0，return
2，当目标值为0 并且 节点下无其他节点
节点下无其他节点说明是叶子节点，并且路径值的和满足了目标值，添加到结果中  并且return
3，当目标值大于0，继续递归
```

```r
class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        # write code here
        path = []
        res = []
        def dfs(root, sum):
            if not root:
                return
            path.append(root.val)
            sum -= root.val
            if sum == 0 and not root.left and not root.right:
                res.append(path[:])
            dfs(root.left, sum)
            dfs(root.right, sum)
            path.pop()
            
        dfs(root, expectNumber)
        return res
```

**仔细去想上面三个题的思路**


## 复杂链表的复制

**题目描述**
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

思路：


```r
class Solution:
    # 返回 RandomListNode
    def Clone(self, pHead):
        # write code here
        if not pHead:
            return None
        newp = RandomListNode(pHead.label)
        newp.random = pHead.random
        newp.next = self.Clone(pHead.next)
        return newp
```

或者下面这一句也是可以的

```r
return copy.deepcopy(pHead)
```


## 反转单词顺序

**题目描述**

牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？


能~

字符串的倒序，注意输出的结果表示

```r
class Solution:
    def ReverseSentence(self, s):
        # write code here
        if not s:
            return ''
        st=s.split(' ')
        res=st[::-1]
        return ' '.join(res)
```

## 左旋字符串

**题目描述**
汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

```r
class Solution:
    def LeftRotateString(self, s, n):
        # write code here
        l=len(s)
        return s[n:]+s[:n]
        
```


## 把数组排成最小整数

**题目描述**
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

把数组变成字符串，完事就是常规的冒泡排序就能解决。。冒泡排序的应用

str和int之间的转换，这个需要知道一下


```r
# -*- coding:utf-8 -*-
class Solution:
    def PrintMinNumber(self, numbers):
    # write code here
        n = len(numbers)
        for i in range(n):
            for j in range(i+1, n):
                if int(str(numbers[i]) + str(numbers[j]) > str(numbers[j]) + str(numbers[i])):
                    numbers[j], numbers[i] = numbers[i], numbers[j]
        return ''.join([str(i) for i in numbers])
```



## 丑数

**题目描述**
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。


**思路：**丑数 = 已有的丑数 * (2,3,5) 得到三个新的丑数，但是新的丑数位置不一定正确，切可能会有重复

所以我们每次只新增一个最小值，然后用三个指针记录当前2，3，5质因子形成的最大丑数位置，这样的话就会形成递增的丑数队列，而且遍历的次数也很容易就知道，即n-1,因为1是第一个丑数，n-1次遍历后，我们就可以得到一个含有n个丑数的有序数组，返回最后一个即可。

```r
# -*- coding:utf-8 -*-
class Solution:
    def GetUglyNumber_Solution(self, index):
    # write code here
        if index <= 0:
            return 0
        uglyList = [1]
        p2 = 0 # p2指向小于newUgly且最大的乘以2后可能成为下一个丑数的丑数
        p3 = 0 # p3指向小于newUgly且最大的乘以3后可能成为下一个丑数的丑数
        p5 = 0 # p5指向小于newUgly且最大的乘以5后可能成为下一个丑数的丑数
        for i in range(index-1):
            newUgly = min(uglyList[p2]*2, uglyList[p3]*3, uglyList[p5]*5)
            uglyList.append(newUgly)
            if (newUgly % 2 == 0):
                p2 += 1
            if (newUgly % 3 == 0):
                p3 += 1
            if (newUgly % 5 == 0):
                p5 += 1
        return uglyList[-1]
```


## 第一个只出现一次的字符串

**题目描述**
在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

简单解法，count计数法

```r
# -*- coding:utf-8 -*-
class Solution:
    def FirstNotRepeatingChar(self, s):
        # write code here
        if not s:
            return -1
        for i in range(len(s)):
            if s.count(s[i]) == 1:
                return i
        return -1
```

或者直接字典

```r
# -*- coding:utf-8 -*-
class Solution:
    def FirstNotRepeatingChar(self, s):
        # write code here
        if len(s) == 0:
            return -1
        for index, value in enumerate(s):
            if s.count(value) == 1:
                return index
```


## 数组中的逆序对

**题目描述**

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

输入描述:
题目保证输入的数组中没有的相同的数字

数据范围：

对于%50的数据,size<=10^4

对于%75的数据,size<=10^5

对于%100的数据,size<=2*10^5

示例1
输入1,2,3,4,5,6,7,0

输出7

思路1：先将原序列排序，然后从排完序的数组中取出最小的，它在原数组中的位置表示有多少比它大的数在它前面，每取出一个在原数组中删除该元素，保证后面取出的元素在原数组中是最小的，这样其位置才能表示有多少比它大的数在它前面，即逆序对数。


```r

# -*- coding:utf-8 -*-
class Solution:
    def InversePairs(self, data):
        # write code here
        cnt = 0
        copy = data[:]
        copy.sort()
        for i in copy:
            cnt += data.index(i)
            data.remove(i)
        return cnt%1000000007
```

思路2：归并排序
冒泡排序太暴力了

待我默写出来


## 两个链表的第一个公共节点

**题目描述**

输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

思路1
如果能从后面遍历两个链表，找到最后一个相同的节点，输出即可。可以利用两个栈来实现。


```r
#         self.next = None
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        # write code here
        if pHead1== None or pHead2 == None:
            return None
        stack1 = []
        stack2 = []
        p1 = pHead1
        while p1 is not None:   # 依次将两个链表的所有节点分别压入两个栈中
            stack1.append(p1)
            p1 = p1.next
        p2 = pHead2
        while p2 is not None:
            stack2.append(p2)
            p2 = p2.next
        res = None
        while len(stack1) > 0 and len(stack2) > 0:
        # 从后往前遍历，直到找到两个链表相同的最后一个节点，如果相同的话。
            v1 = stack1.pop()
            v2 = stack2.pop()
            if v1 == v2:
                res = v1
            else:
                break
        return res

```

下面这个思路好骚啊~[csdn](https://blog.csdn.net/ggdhs/article/details/90319403)

感觉有点不懂

![](figs/lbggjd.png)

```r
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        # write code here
        if pHead1== None or pHead2 == None:
            return None
        p1 = pHead1
        p2 = pHead2
        while(p1!=p2):  
            p1 = pHead2 if p1 is None else p1.next
            # 由于若pHead2是pHead1的最后一个节点，，因此不能以p1.next==None作为判断条件。
            # 否则就会死循环。
            p2 = pHead1 if p2 is None else p2.next
        return p1
```


## 数字在升序数组中出现的次数


**题目描述**

统计一个数字在升序数组中出现的次数。

怎么写都能通过吧

```r
# -*- coding:utf-8 -*-
class Solution:
    def GetNumberOfK(self, data, k):
        # write code here
        count = 0
        for i in range(len(data)):
            if(data[i] == k):
                count += 1
        return count
        # 或者就直接用python的count函数
        # return data.count(k)
```


## 平衡二叉树


**题目描述**
输入一棵二叉树，判断该二叉树是否是平衡二叉树。

在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树

首先啊得了解啥是平衡二叉树

**一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值小于1。**

大于1就返回fasle呗


## 数组中只出现一次的数

**题目描述**
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。


```r
# -*- coding:utf-8 -*-
class Solution:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
        # write code here
        res=[]
        for i in array:
            if array.count(i)==1:
                res.append(i)
        return res
```

## 和为S的连续子序列

**题目描述**

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

**思路1**
在连续的正数序列中，如果一个数比和的一半要大的话，如和为100，其中一个数是51，那么，存在51且和等于100的这个序列是不存在的。因此，我们可以借助两个循环，来循环遍历所有和等于tsum的序列。

也就是穷举法

```r
# -*- coding:utf-8 -*-
class Solution:
    def FindContinuousSequence(self, tsum):
        # write code here
        res = []
        for i in range(1, tsum//2+1): 遍历一半就行了
            sum = 0
            for j in range(i, tsum//2+2):
                sum += j
                if sum == tsum:
                    res.append(list(range(i, j+1)))
                if sum > tsum:
                    break
        return res
```

*思路2*


>利用一个双指针来实现一个滑动窗口，如果当前窗口内的和等于tsum，返回窗口内的所有数，并且移动窗口，窗口右侧向右移动一位或者左侧右移一位都行，如果小于tsum的话，窗口的左侧向右移动一位，如果大于tsum的话，窗口的右侧向左移动一位，循环终止条件是，窗口左侧，即（窗口左侧）序列的最小值大于tsum//2，即思路1中的不会有数大于和的一半。[csdn](https://blog.csdn.net/ggdhs/article/details/90344263)


滑动窗口的思想真的挺常见的，要熟练使用哇

```r
# -*- coding:utf-8 -*-
class Solution:
    def FindContinuousSequence(self, tsum):
        # write code here
        if tsum == 1:
            return []
        small = 1
        big = 2
        mid = tsum//2
        sum = big+small       # 用来不断更新当前序列的和，也可以利用求和公式。
        ret = []
        while small <= mid:
            if sum == tsum:
                ret.append(list(range(small,big+1)))
                big += 1       # 如果右侧窗口移动，先移动在加
                sum += big     # 不断更新，也可以利用求和公式来计算窗口内数的和
            elif sum < tsum:
                big += 1      
                sum += big
            else:             # 如果左侧窗口移动，先减在移动
                sum -= small
                small += 1
        return ret
```

## 两个数之和为s

**题目描述**
输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

easy题

```r
# -*- coding:utf-8 -*-
class Solution:
    def FindNumbersWithSum(self, array, tsum):
        # write code here
        if not array or not tsum:
            return []
        result = []
        for i in array:
            if (tsum - i) in array:
                result.append([i, tsum - i])
        if result:
            result.sort(key=lambda x: x[0] * x[1])
            result = result[0]
            return result
        return []
```
