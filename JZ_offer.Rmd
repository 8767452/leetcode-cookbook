---
title: "剑指offer"
author: "wenxin Gao"
date: "2020/8/10"
output: html_document
---

# 剑指offer题解

安装牛客网的顺序的来的~


## 二维数组中的查找

**题目描述**
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。


思路：最先想到的遍历一遍数组，判断target是否在数组中即可

```r

class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        for arr in array:
            if target in arr:
                return True
        return False
```

## 替换空格

**题目描述**
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

思路:

最先能想到replace，哈哈~直接替换

```r
# -*- coding:utf-8 -*-
import re
class Solution:
    # s 源字符串
    def replaceSpace(self, s):
        # write code here
        return s.replace(' ','%20')
```


## 从头到尾打印链表

**题目描述**

输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

从尾到头的顺序，第一个感觉是reverse，但是感觉这么写会被打~

还是一样的问题：有几天

```r

# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        res = []
        while listNode:
            
            res.append(listNode.val)
            listNode = listNode.next
        return res[::-1]

```

## 重建二叉树

**题目描述**

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。



**思路**:递归加迭代

知识点：

前序遍历列表：第一个元素永远是 【根节点 (root)】
中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】

算法思路：

通过【前序遍历列表】确定【根节点 (root)】
将【中序遍历列表】的节点分割成【左分支节点】和【右分支节点】
递归寻找【左分支节点】中的【根节点 (left child)】和 【右分支节点】中的【根节点 (right child)】

就是在考察前序中序后序树的遍历顺序:前序第一个是根节点，找到根节点在中序中的位置，可以划分左右子树，然后递归即可

```r
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if len(inorder) == 0:
            return None
        
        # 根节点
        root = TreeNode(preorder[0]) #前序遍历找根节点~
        # 获取根节点在 inorder 中的索引
        idx = inorder.index(preorder[0]) # 找到根节点的索引
        # 左子树
        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx]) # 
        # 右子树
        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])
        return root

```

## 两个栈实现队列

栈：先进后厨
队列：先进先出

**题目描述**

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

找个主要如果用牛客的话需要自己先定义两个空队列

```r
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def push(self, node):
        # write code here
        self.stack1.append(node)
    def pop(self):
        # return xx
        if len(self.stack2) == 0: # 第二个是空队列哦
            while len(self.stack1) !=0:
                self.stack2.append(self.stack1[len(self.stack1)-1]) # 先进先出
                self.stack1.pop()
        pop = self.stack2[len(self.stack1)-1]
        self.stack2.pop()
        return pop
```



## 旋转数组中最小的数

**题目描述**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

思路：第一感觉，一个min函数不就完事了，但是这么写没有意义，面试官会说你把min的底层写出来~

呵呵 了

因此肯定考排序这里的，比如二分法查找~

保证rotateArray[left]为全场最小，当rotateArray[left]<rotateArray[right]时，证明进入了有序数组，直接输出

```r
# -*- coding:utf-8 -*-
class Solution:
    def minNumberInRotateArray(self, rotateArray,):
        # write code here
        if len(rotateArray) == 0:
            return 0
        # 二分法查找,快排
        left = 0
        right = len(rotateArray)-1
        while left<right: #从左向右开始遍历
            if rotateArray[left]<rotateArray[right]:
                return rotateArray[left]
            mid = left + (right -left)//2
            # 左边 有序取另一半
            
            if rotateArray[left]<rotateArray[mid]:
                left = mid +1
            # 右边有序右边取最小
            elif rotateArray[mid]<rotateArray[right]:
                right = mid
             #前面两个相等的时候，left进一继续
            else :
                left+=1
        return rotateArray[left]
```


