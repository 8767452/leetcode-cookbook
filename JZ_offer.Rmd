---
title: "剑指offer"
author: "wenxin Gao"
date: "2020/8/10"
output: html_document
---

# 剑指offer题解

安装牛客网的顺序的来的~


## 二维数组中的查找

**题目描述**
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。


思路：最先想到的遍历一遍数组，判断target是否在数组中即可

```r

class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        for arr in array:
            if target in arr:
                return True
        return False
```

## 替换空格

**题目描述**
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

思路:

最先能想到replace，哈哈~直接替换

```r
# -*- coding:utf-8 -*-
import re
class Solution:
    # s 源字符串
    def replaceSpace(self, s):
        # write code here
        return s.replace(' ','%20')
```


## 从头到尾打印链表

**题目描述**

输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

从尾到头的顺序，第一个感觉是reverse，但是感觉这么写会被打~

还是一样的问题：有几天

```r

# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        res = []
        while listNode:
            
            res.append(listNode.val)
            listNode = listNode.next
        return res[::-1]

```

## 重建二叉树

**题目描述**

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。



**思路**:递归加迭代

知识点：

前序遍历列表：第一个元素永远是 【根节点 (root)】
中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】

算法思路：

通过【前序遍历列表】确定【根节点 (root)】
将【中序遍历列表】的节点分割成【左分支节点】和【右分支节点】
递归寻找【左分支节点】中的【根节点 (left child)】和 【右分支节点】中的【根节点 (right child)】

就是在考察前序中序后序树的遍历顺序:前序第一个是根节点，找到根节点在中序中的位置，可以划分左右子树，然后递归即可

```r
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if len(inorder) == 0:
            return None
        
        # 根节点
        root = TreeNode(preorder[0]) #前序遍历找根节点~
        # 获取根节点在 inorder 中的索引
        idx = inorder.index(preorder[0]) # 找到根节点的索引
        # 左子树
        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx]) # 
        # 右子树
        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])
        return root

```

## 两个栈实现队列

栈：先进后厨
队列：先进先出

**题目描述**

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

找个主要如果用牛客的话需要自己先定义两个空队列

```r
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def push(self, node):
        # write code here
        self.stack1.append(node)
    def pop(self):
        # return xx
        if len(self.stack2) == 0: # 第二个是空队列哦
            while len(self.stack1) !=0:
                self.stack2.append(self.stack1[len(self.stack1)-1]) # 先进先出
                self.stack1.pop()
        pop = self.stack2[len(self.stack1)-1]
        self.stack2.pop()
        return pop
```



## 旋转数组中最小的数

**题目描述**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

思路：第一感觉，一个min函数不就完事了，但是这么写没有意义，面试官会说你把min的底层写出来~

呵呵 了

因此肯定考排序这里的，比如二分法查找~

保证rotateArray[left]为全场最小，当rotateArray[left]<rotateArray[right]时，证明进入了有序数组，直接输出

```r
# -*- coding:utf-8 -*-
class Solution:
    def minNumberInRotateArray(self, rotateArray,):
        # write code here
        if len(rotateArray) == 0:
            return 0
        # 二分法查找,快排
        left = 0
        right = len(rotateArray)-1
        while left<right: #从左向右开始遍历
            if rotateArray[left]<rotateArray[right]:
                return rotateArray[left]
            mid = left + (right -left)//2
            # 左边 有序取另一半
            
            if rotateArray[left]<rotateArray[mid]:
                left = mid +1
            # 右边有序右边取最小
            elif rotateArray[mid]<rotateArray[right]:
                right = mid
             #前面两个相等的时候，left进一继续
            else :
                left+=1
        return rotateArray[left]
```

## 斐波那契数列

**题目描述**
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。
n<=39

直接给出动态规划的解法，省内存

```r

# -*- coding:utf-8 -*-
class Solution:
    def Fibonacci(self, n):
        # write code here
        num = {}
        num[0] = 0
        num[1] = 1
        if n > 1:
            for i in range(2,n+1):
                num[i] = num[i-2] + num[i-1]
        return int(num[n]%(1000000007))

# 绝了，一开始最后的结果没除1000000007取余，死活通不过
```

## 青蛙跳台阶问题

**题目描述**
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

```r
class Solution:
    def jumpFloor(self, number):
        # write code here
        if number==1:
            return 1
        res=[1,2]
        for i in range(2,number):
            res.append(res[i-1]+res[i-2])
        return res[-1]
```


## 变态跳台问题

加强版

**题目描述**

一只青蛙一次可以跳上1级台阶，也可以跳上2级……*它也可以跳上n级*。求该青蛙跳上一个n级的台阶总共有多少种跳法。

一般**递归**能解决大部分的问题

易知 f(n)=f(n-1)+f(n-2)+……f(1)
f(n-1)=f(n-2)+……f(1)
两式相减得f(n)=2f(n-1)

```r
class Solution:
    def jumpFloorII(self, number):
        # write code here
        n=1 
        for i in range(2,number+1):
            n=2*n
        return n
        
```


## 矩形覆盖

**题目描述**
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

![](figs/jxfg.png)

思想：和跳台阶类似，小矩形竖着放相当于跳一级台阶，横着放相当于跳两级台阶，所以可以复用跳台阶的代码（见第八题）。


```r
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloor(self, number):
        # write code here
        if number == 0:
            return 0
        res = [0,1,2]
        for i in range(3,number+1):
            res.append(res[i-1]+res[i-2])
        return res[number]
        
```

## 二进制中的1的个数

**题目描述**
输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。

其实我jio的一行就行了，bin+count,但是牛客不给通过

```r

#class Solution:
    
   def NumberOf1(self, n):
        # write code here
        
       return bin(n).count('1')
```

还是得用正常的方式
```r
class Solution:
    def NumberOf1(self, n):
        # write code here
        count = 0
        if n < 0:
            n = n & 0xffffffff
        while n:
                count += 1
                n = (n - 1) & n
        return count
        
```
## 数值得整熟次方

**题目描述**

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0

实现底层得pow，限制条件多，但是不难得，京东一面其中一个算法题

```r
# -*- coding:utf-8 -*-
class Solution:
    def Power(self, base, exponent):
        # write code here
        temp = base
        # 0的0次方和0的负数次方无意义
        if base == 0.0 and exponent <= 0:
            return None
        #0的次方为0
        if base == 0.0 :
            return 0
        #除0以外的任何数的0次方都为0
        if exponent == 0:
            return 1
        #负数次方时
        if exponent < 0:
            for i in range(-exponent-1):
                base *= temp
            return 1.0 / base
        else:
            #正数次方时
            for i in range(exponent-1):
                base *= temp
            return base
```


今天贝壳找房得笔试挂了，因此多来三个题平复下心情~

算法虐我千百遍我待算法如初恋~


## 调整数组顺序使其位于整熟前面

**题目描述**

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。


给一个常规得解法

```r
class Solution:
    def reOrderArray(self, array):
        # write code here
        j=[]
        o=[]
        for i in array:
            if i%2==0:
                o.append(i)
            else:
                j.append(i)
        return j+o
        
```

## 链表的倒数第k个节点

题目描述
输入一个链表，输出该链表中倒数第k个结点。

用一个最直观的方法，时间复杂度为o（k)

```r

class Solution:
    def FindKthToTail(self, head, k):
        # write code here
        #哎，你就把链表当一个list去遍历呗,只是向下移动的方式是不一样的
        res=[]
        while head:
            res.append(head)
            head=head.next
        if k>len(res) or k<1:
            return 
        return res[-k]
        
```


## 反转链表

**题目描述**
输入一个链表，反转链表后，输出新链表的表头。

自己画个图就非常的明白了


```r
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        
        p = None
        while pHead:
            curr=pHead
            pHead=pHead.next
            curr.next=p
            p=curr
        return p
```

突然发现，今天笔试题不会的原因是因为，比较重要的5个排序没有学透！！


## 合并两个有序链表

**题目描述**
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

```r

class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        # write code here
        if not pHead1:
            return pHead2
        if not pHead2:
            return pHead1
        if pHead1.val<pHead2.val:
            pHead1.next = self.Merge(pHead1.next,pHead2)
            return pHead1
        else:
            pHead2.next = self.Merge(pHead1,pHead2.next)
            return pHead2
```

## 树的子结构

**题目描述**

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）





## 二叉树的镜像

题目描述
操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述:
二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
    	
    	
思路：交换左右子树

```r
# -*- coding:utf-8 -*-
class TreeNode:
     def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
 
class Solution:
    # 返回镜像树的根节点
    def Mirror(self, root):
        # write code here
        if not root:
            return 
        root.left,root.right =root.right,root.left
        self.Mirror(root.left)
        self.Mirror(root.right)
        return root
```

## 顺时针打印矩阵

**题目描述**
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.